{"version":3,"file":"index.umd.cjs","sources":["../../../../../node_modules/.pnpm/@tmagic+form-schema@1.6.0_typescript@5.9.2/node_modules/@tmagic/form-schema/dist/tmagic-form-schema.js","../../../../../node_modules/.pnpm/@tmagic+vue-button@0.2.0_@tmagic+core@1.6.0_typescript@5.9.2__@tmagic+vue-runtime-help@_6fdc37761472e4baef276f6f0baa26f5/node_modules/@tmagic/vue-button/src/formConfig.ts","../../../../../node_modules/.pnpm/events@3.3.0/node_modules/events/events.js","../../../../../node_modules/.pnpm/deep-state-observer@5.5.13/node_modules/deep-state-observer/index.esm.js","../../../../../node_modules/.pnpm/@tmagic+schema@1.6.0_typescript@5.9.2/node_modules/@tmagic/schema/dist/tmagic-schema.js","../../../../../node_modules/.pnpm/@tmagic+utils@1.6.0_@tmagic+schema@1.6.0_typescript@5.9.2__typescript@5.9.2/node_modules/@tmagic/utils/dist/tmagic-utils.js","../../../../../node_modules/.pnpm/@tmagic+vue-container@1.2.0_@tmagic+core@1.6.0_typescript@5.9.2__@tmagic+vue-runtime-he_6890d2f5f27c4de0dc53e3198607c099/node_modules/@tmagic/vue-container/src/formConfig.ts","../../../../../node_modules/.pnpm/@tmagic+vue-img@0.2.0_@tmagic+core@1.6.0_typescript@5.9.2__@tmagic+vue-runtime-help@1.2_479ec34a05f68bcb9bfcbf7fa2deb98f/node_modules/@tmagic/vue-img/src/formConfig.ts","../../../../../node_modules/.pnpm/@tmagic+vue-iterator-container@0.2.2_@tmagic+core@1.6.0_typescript@5.9.2__@tmagic+vue-r_55bb8bd30aceb1cc9729fa86d752a135/node_modules/@tmagic/vue-iterator-container/src/formConfig.ts","../../../../../node_modules/.pnpm/@tmagic+vue-overlay@0.2.0_@tmagic+core@1.6.0_typescript@5.9.2__@tmagic+vue-runtime-help_d2323dafed08b37027dcaa710bbfcfd2/node_modules/@tmagic/vue-overlay/src/formConfig.ts","../../../../../node_modules/.pnpm/@tmagic+vue-page@0.2.1_@tmagic+core@1.6.0_typescript@5.9.2__@tmagic+vue-runtime-help@1._0c0ae0503bc0f6064ac4718f1030ebe1/node_modules/@tmagic/vue-page/src/formConfig.ts","../../../../../node_modules/.pnpm/@tmagic+vue-page-fragment@0.2.0_@tmagic+core@1.6.0_typescript@5.9.2__@tmagic+vue-runtim_046bfc4f5e38c118d46f47413eacd6ba/node_modules/@tmagic/vue-page-fragment/src/formConfig.ts","../../../../../node_modules/.pnpm/@tmagic+vue-page-fragment-container@0.2.2_@tmagic+core@1.6.0_typescript@5.9.2__@tmagic+_205d196daa108182891029be0df24f57/node_modules/@tmagic/vue-page-fragment-container/src/formConfig.ts","../../../../../node_modules/.pnpm/@tmagic+vue-qrcode@0.2.0_@tmagic+core@1.6.0_typescript@5.9.2__@tmagic+vue-runtime-help@_c35ed690dcef1473c1065415a62f36a5/node_modules/@tmagic/vue-qrcode/src/formConfig.ts","../../../../../node_modules/.pnpm/@tmagic+vue-text@0.2.1_@tmagic+core@1.6.0_typescript@5.9.2__@tmagic+vue-runtime-help@1._069cafdf3d99c92b353c0cebfc7e783e/node_modules/@tmagic/vue-text/src/formConfig.ts","../../../.tmagic/config-entry.ts"],"sourcesContent":["const defineFormConfig = (config) => config;\n\nexport { defineFormConfig };\n","/*\n * Tencent is pleased to support the open source community by making TMagicEditor available.\n *\n * Copyright (C) 2025 Tencent.  All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { defineFormConfig } from '@tmagic/form-schema';\n\nexport default defineFormConfig([\n  {\n    name: 'className',\n    type: 'data-source-input',\n    text: 'class',\n  },\n  {\n    text: '文本',\n    name: 'text',\n    type: 'data-source-input',\n  },\n]);\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\n\n// forked from https://github.com/joonhocho/superwild\r\nconst segments = [];\r\nfunction Match(pattern, match, wchar = \"*\") {\r\n    if (pattern === wchar) {\r\n        return true;\r\n    }\r\n    segments.length = 0;\r\n    let starCount = 0;\r\n    let minLength = 0;\r\n    let maxLength = 0;\r\n    let segStartIndex = 0;\r\n    for (let i = 0, len = pattern.length; i < len; i += 1) {\r\n        const char = pattern[i];\r\n        if (char === wchar) {\r\n            starCount += 1;\r\n            if (i > segStartIndex) {\r\n                segments.push(pattern.substring(segStartIndex, i));\r\n            }\r\n            segments.push(char);\r\n            segStartIndex = i + 1;\r\n        }\r\n    }\r\n    if (segStartIndex < pattern.length) {\r\n        segments.push(pattern.substring(segStartIndex));\r\n    }\r\n    if (starCount) {\r\n        minLength = pattern.length - starCount;\r\n        maxLength = Infinity;\r\n    }\r\n    else {\r\n        maxLength = minLength = pattern.length;\r\n    }\r\n    if (segments.length === 0) {\r\n        return pattern === match;\r\n    }\r\n    const length = match.length;\r\n    if (length < minLength || length > maxLength) {\r\n        return false;\r\n    }\r\n    let segLeftIndex = 0;\r\n    let segRightIndex = segments.length - 1;\r\n    let rightPos = match.length - 1;\r\n    let rightIsStar = false;\r\n    while (true) {\r\n        const segment = segments[segRightIndex];\r\n        segRightIndex -= 1;\r\n        if (segment === wchar) {\r\n            rightIsStar = true;\r\n        }\r\n        else {\r\n            const lastIndex = rightPos + 1 - segment.length;\r\n            const index = match.lastIndexOf(segment, lastIndex);\r\n            if (index === -1 || index > lastIndex) {\r\n                return false;\r\n            }\r\n            if (rightIsStar) {\r\n                rightPos = index - 1;\r\n                rightIsStar = false;\r\n            }\r\n            else {\r\n                if (index !== lastIndex) {\r\n                    return false;\r\n                }\r\n                rightPos -= segment.length;\r\n            }\r\n        }\r\n        if (segLeftIndex > segRightIndex) {\r\n            break;\r\n        }\r\n    }\r\n    return true;\r\n}\n\nclass WildcardObject {\r\n    constructor(obj, delimiter, wildcard, is_match = undefined) {\r\n        this.obj = obj;\r\n        this.delimiter = delimiter;\r\n        this.wildcard = wildcard;\r\n        this.is_match = is_match;\r\n    }\r\n    shortMatch(first, second) {\r\n        if (first === second)\r\n            return true;\r\n        if (first === this.wildcard)\r\n            return true;\r\n        if (this.is_match)\r\n            return this.is_match(first, second);\r\n        const index = first.indexOf(this.wildcard);\r\n        if (index > -1) {\r\n            const end = first.substr(index + 1);\r\n            if (index === 0 || second.substring(0, index) === first.substring(0, index)) {\r\n                const len = end.length;\r\n                if (len > 0) {\r\n                    return second.substr(-len) === end;\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    match(first, second) {\r\n        if (this.is_match)\r\n            return this.is_match(first, second);\r\n        return (first === second ||\r\n            first === this.wildcard ||\r\n            second === this.wildcard ||\r\n            this.shortMatch(first, second) ||\r\n            Match(first, second, this.wildcard));\r\n    }\r\n    handleArray(wildcard, currentArr, partIndex, path, result = {}) {\r\n        let nextPartIndex = wildcard.indexOf(this.delimiter, partIndex);\r\n        let end = false;\r\n        if (nextPartIndex === -1) {\r\n            end = true;\r\n            nextPartIndex = wildcard.length;\r\n        }\r\n        const currentWildcardPath = wildcard.substring(partIndex, nextPartIndex);\r\n        let index = 0;\r\n        for (const item of currentArr) {\r\n            const key = index.toString();\r\n            const currentPath = path === \"\" ? key : path + this.delimiter + index;\r\n            if (currentWildcardPath === this.wildcard ||\r\n                currentWildcardPath === key ||\r\n                this.shortMatch(currentWildcardPath, key)) {\r\n                end ? (result[currentPath] = item) : this.goFurther(wildcard, item, nextPartIndex + 1, currentPath, result);\r\n            }\r\n            index++;\r\n        }\r\n        return result;\r\n    }\r\n    handleObject(wildcardPath, currentObj, partIndex, path, result = {}) {\r\n        let nextPartIndex = wildcardPath.indexOf(this.delimiter, partIndex);\r\n        let end = false;\r\n        if (nextPartIndex === -1) {\r\n            end = true;\r\n            nextPartIndex = wildcardPath.length;\r\n        }\r\n        const currentWildcardPath = wildcardPath.substring(partIndex, nextPartIndex);\r\n        for (let key in currentObj) {\r\n            key = key.toString();\r\n            const currentPath = path === \"\" ? key : path + this.delimiter + key;\r\n            if (currentWildcardPath === this.wildcard ||\r\n                currentWildcardPath === key ||\r\n                this.shortMatch(currentWildcardPath, key)) {\r\n                if (end) {\r\n                    result[currentPath] = currentObj[key];\r\n                }\r\n                else {\r\n                    this.goFurther(wildcardPath, currentObj[key], nextPartIndex + 1, currentPath, result);\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    goFurther(path, currentObj, partIndex, currentPath, result = {}) {\r\n        if (Array.isArray(currentObj)) {\r\n            return this.handleArray(path, currentObj, partIndex, currentPath, result);\r\n        }\r\n        return this.handleObject(path, currentObj, partIndex, currentPath, result);\r\n    }\r\n    get(path) {\r\n        return this.goFurther(path, this.obj, 0, \"\");\r\n    }\r\n}\n\nclass ObjectPath {\r\n    static get(path, obj, create = false) {\r\n        if (!obj)\r\n            return;\r\n        let currObj = obj;\r\n        for (const currentPath of path) {\r\n            if (currentPath in currObj) {\r\n                currObj = currObj[currentPath];\r\n            }\r\n            else if (create) {\r\n                currObj[currentPath] = Object.create({});\r\n                currObj = currObj[currentPath];\r\n            }\r\n            else {\r\n                return;\r\n            }\r\n        }\r\n        return currObj;\r\n    }\r\n    static set(path, value, obj) {\r\n        if (!obj)\r\n            return;\r\n        if (path.length === 0) {\r\n            for (const key in obj) {\r\n                delete obj[key];\r\n            }\r\n            for (const key in value) {\r\n                obj[key] = value[key];\r\n            }\r\n            return;\r\n        }\r\n        const prePath = path.slice();\r\n        const lastPath = prePath.pop();\r\n        const get = ObjectPath.get(prePath, obj, true);\r\n        if (typeof get === \"object\") {\r\n            get[lastPath] = value;\r\n        }\r\n        return value;\r\n    }\r\n}\n\nlet wasm;\n\nlet WASM_VECTOR_LEN = 0;\n\nlet cachegetUint8Memory0 = null;\nfunction getUint8Memory0() {\n  if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {\n    cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n  }\n  return cachegetUint8Memory0;\n}\n\nlet cachedTextEncoder = new TextEncoder(\"utf-8\");\n\nconst encodeString =\n  typeof cachedTextEncoder.encodeInto === \"function\"\n    ? function (arg, view) {\n        return cachedTextEncoder.encodeInto(arg, view);\n      }\n    : function (arg, view) {\n        const buf = cachedTextEncoder.encode(arg);\n        view.set(buf);\n        return {\n          read: arg.length,\n          written: buf.length,\n        };\n      };\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n  if (realloc === undefined) {\n    const buf = cachedTextEncoder.encode(arg);\n    const ptr = malloc(buf.length);\n    getUint8Memory0()\n      .subarray(ptr, ptr + buf.length)\n      .set(buf);\n    WASM_VECTOR_LEN = buf.length;\n    return ptr;\n  }\n\n  let len = arg.length;\n  let ptr = malloc(len);\n\n  const mem = getUint8Memory0();\n\n  let offset = 0;\n\n  for (; offset < len; offset++) {\n    const code = arg.charCodeAt(offset);\n    if (code > 0x7f) break;\n    mem[ptr + offset] = code;\n  }\n\n  if (offset !== len) {\n    if (offset !== 0) {\n      arg = arg.slice(offset);\n    }\n    ptr = realloc(ptr, len, (len = offset + arg.length * 3));\n    const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n    const ret = encodeString(arg, view);\n\n    offset += ret.written;\n  }\n\n  WASM_VECTOR_LEN = offset;\n  return ptr;\n}\n/**\n * @param {string} pattern\n * @param {string} input\n * @returns {boolean}\n */\nfunction is_match(pattern, input) {\n  var ptr0 = passStringToWasm0(pattern, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n  var len0 = WASM_VECTOR_LEN;\n  var ptr1 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n  var len1 = WASM_VECTOR_LEN;\n  var ret = wasm.is_match(ptr0, len0, ptr1, len1);\n  return ret !== 0;\n}\n\nasync function load(module, imports) {\n  if (typeof Response === \"function\" && module instanceof Response) {\n    if (typeof WebAssembly.instantiateStreaming === \"function\") {\n      try {\n        return await WebAssembly.instantiateStreaming(module, imports);\n      } catch (e) {\n        if (module.headers.get(\"Content-Type\") != \"application/wasm\") {\n          console.warn(\n            \"`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\",\n            e\n          );\n        } else {\n          throw e;\n        }\n      }\n    }\n\n    const bytes = await module.arrayBuffer();\n    return await WebAssembly.instantiate(bytes, imports);\n  } else {\n    const instance = await WebAssembly.instantiate(module, imports);\n\n    if (instance instanceof WebAssembly.Instance) {\n      return { instance, module };\n    } else {\n      return instance;\n    }\n  }\n}\n\nasync function init(input) {\n  const imports = {};\n  if (\n    typeof input === \"string\" ||\n    (typeof Request === \"function\" && input instanceof Request) ||\n    (typeof URL === \"function\" && input instanceof URL)\n  ) {\n    input = fetch(input);\n  }\n  const { instance, module } = await load(await input, imports);\n  wasm = instance.exports;\n  init.__wbindgen_wasm_module = module;\n  return wasm;\n}\n\nconst defaultUpdateOptions = {\r\n    only: [],\r\n    source: \"\",\r\n    debug: false,\r\n    data: undefined,\r\n    queue: false,\r\n    force: false,\r\n};\r\nfunction log(message, info) {\r\n    console.debug(message, info);\r\n}\r\nfunction getDefaultOptions() {\r\n    return {\r\n        delimiter: `.`,\r\n        debug: false,\r\n        extraDebug: false,\r\n        useMute: true,\r\n        notRecursive: `;`,\r\n        param: `:`,\r\n        wildcard: `*`,\r\n        experimentalMatch: false,\r\n        queue: false,\r\n        defaultBulkValue: true,\r\n        useCache: false,\r\n        useSplitCache: false,\r\n        useIndicesCache: false,\r\n        maxSimultaneousJobs: 1000,\r\n        maxQueueRuns: 1000,\r\n        log,\r\n        Promise,\r\n    };\r\n}\r\n/**\r\n * Is object - helper function to determine if specified variable is an object\r\n *\r\n * @param {any} item\r\n * @returns {boolean}\r\n */\r\nfunction isObject(item) {\r\n    if (item && item.constructor) {\r\n        return item.constructor.name === \"Object\";\r\n    }\r\n    return typeof item === \"object\" && item !== null;\r\n}\r\nclass DeepState {\r\n    constructor(data = {}, options = {}) {\r\n        this.jobsRunning = 0;\r\n        this.updateQueue = [];\r\n        this.subscribeQueue = [];\r\n        this.listenersIgnoreCache = new WeakMap();\r\n        this.is_match = null;\r\n        this.destroyed = false;\r\n        this.queueRuns = 0;\r\n        this.groupId = 0;\r\n        this.namedGroups = [];\r\n        this.numberGroups = [];\r\n        this.traceId = 0;\r\n        this.traceMap = new Map();\r\n        this.tracing = [];\r\n        this.savedTrace = [];\r\n        this.collection = null;\r\n        this.collections = 0;\r\n        this.cache = new Map();\r\n        this.splitCache = new Map();\r\n        this.indices = new Map();\r\n        this.indicesCount = new Map();\r\n        this.lastExecs = new WeakMap();\r\n        this.listeners = new Map();\r\n        this.waitingListeners = new Map();\r\n        this.options = Object.assign(Object.assign({}, getDefaultOptions()), options);\r\n        this.data = data;\r\n        this.id = 0;\r\n        if (!this.options.useCache) {\r\n            this.pathGet = ObjectPath.get;\r\n            this.pathSet = ObjectPath.set;\r\n        }\r\n        else {\r\n            this.pathGet = this.cacheGet;\r\n            this.pathSet = this.cacheSet;\r\n        }\r\n        if (options.Promise) {\r\n            this.resolved = options.Promise.resolve();\r\n        }\r\n        else {\r\n            this.resolved = Promise.resolve();\r\n        }\r\n        this.muted = new Set();\r\n        this.mutedListeners = new Set();\r\n        this.scan = new WildcardObject(this.data, this.options.delimiter, this.options.wildcard);\r\n        this.destroyed = false;\r\n    }\r\n    getDefaultListenerOptions() {\r\n        return {\r\n            bulk: false,\r\n            bulkValue: this.options.defaultBulkValue,\r\n            debug: false,\r\n            source: \"\",\r\n            data: undefined,\r\n            queue: false,\r\n            group: false,\r\n        };\r\n    }\r\n    cacheGet(pathChunks, data = this.data, create = false) {\r\n        const path = pathChunks.join(this.options.delimiter);\r\n        const weakRefValue = this.cache.get(path);\r\n        if (weakRefValue) {\r\n            const value = weakRefValue.deref();\r\n            if (value) {\r\n                return value;\r\n            }\r\n        }\r\n        const value = ObjectPath.get(pathChunks, data, create);\r\n        if (isObject(value) || Array.isArray(value)) {\r\n            // @ts-ignore-next-line\r\n            this.cache.set(path, new WeakRef(value));\r\n        }\r\n        return value;\r\n    }\r\n    cacheSet(pathChunks, value, data = this.data) {\r\n        const path = pathChunks.join(this.options.delimiter);\r\n        if (isObject(value) || Array.isArray(value)) {\r\n            this.cache.set(path, \r\n            //@ts-ignore-next-line\r\n            new WeakRef(value));\r\n        }\r\n        else {\r\n            this.cache.delete(path);\r\n        }\r\n        return ObjectPath.set(pathChunks, value, data);\r\n    }\r\n    /**\r\n     * Silently update data\r\n     * @param path string\r\n     * @param value any\r\n     * @returns\r\n     */\r\n    silentSet(path, value) {\r\n        return this.pathSet(this.split(path), value, this.data);\r\n    }\r\n    loadWasmMatcher(pathToWasmFile) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            yield init(pathToWasmFile);\r\n            this.is_match = is_match;\r\n            this.scan = new WildcardObject(this.data, this.options.delimiter, this.options.wildcard, this.is_match);\r\n        });\r\n    }\r\n    same(newValue, oldValue) {\r\n        return (([\"number\", \"string\", \"undefined\", \"boolean\"].includes(typeof newValue) || newValue === null) &&\r\n            oldValue === newValue);\r\n    }\r\n    getListeners() {\r\n        return this.listeners;\r\n    }\r\n    destroy() {\r\n        this.destroyed = true;\r\n        this.data = undefined;\r\n        this.listeners = new Map();\r\n        this.waitingListeners = new Map();\r\n        this.updateQueue = [];\r\n        this.jobsRunning = 0;\r\n    }\r\n    match(first, second, nested = true) {\r\n        if (this.is_match)\r\n            return this.is_match(first, second);\r\n        if (first === second)\r\n            return true;\r\n        if (first === this.options.wildcard || second === this.options.wildcard)\r\n            return true;\r\n        if (!nested &&\r\n            this.getIndicesCount(this.options.delimiter, first) < this.getIndicesCount(this.options.delimiter, second)) {\r\n            // first < second because first is a listener path and may be longer but not shorter\r\n            return false;\r\n        }\r\n        return this.scan.match(first, second);\r\n    }\r\n    getIndicesOf(searchStr, str) {\r\n        if (this.options.useIndicesCache && this.indices.has(str))\r\n            return this.indices.get(str);\r\n        const searchStrLen = searchStr.length;\r\n        if (searchStrLen == 0) {\r\n            return [];\r\n        }\r\n        let startIndex = 0, index, indices = [];\r\n        while ((index = str.indexOf(searchStr, startIndex)) > -1) {\r\n            indices.push(index);\r\n            startIndex = index + searchStrLen;\r\n        }\r\n        if (this.options.useIndicesCache)\r\n            this.indices.set(str, indices);\r\n        return indices;\r\n    }\r\n    getIndicesCount(searchStr, str) {\r\n        if (this.options.useIndicesCache && this.indicesCount.has(str))\r\n            return this.indicesCount.get(str);\r\n        const searchStrLen = searchStr.length;\r\n        if (searchStrLen == 0) {\r\n            return 0;\r\n        }\r\n        let startIndex = 0, index, indices = 0;\r\n        while ((index = str.indexOf(searchStr, startIndex)) > -1) {\r\n            indices++;\r\n            startIndex = index + searchStrLen;\r\n        }\r\n        if (this.options.useIndicesCache)\r\n            this.indicesCount.set(str, indices);\r\n        return indices;\r\n    }\r\n    cutPath(longer, shorter) {\r\n        if (shorter === \"\")\r\n            return \"\";\r\n        longer = this.cleanNotRecursivePath(longer);\r\n        shorter = this.cleanNotRecursivePath(shorter);\r\n        if (longer === shorter)\r\n            return longer;\r\n        const shorterPartsLen = this.getIndicesCount(this.options.delimiter, shorter);\r\n        const longerParts = this.getIndicesOf(this.options.delimiter, longer);\r\n        return longer.substring(0, longerParts[shorterPartsLen]);\r\n    }\r\n    trimPath(path) {\r\n        path = this.cleanNotRecursivePath(path);\r\n        if (path.charAt(0) === this.options.delimiter) {\r\n            return path.substr(1);\r\n        }\r\n        return path;\r\n    }\r\n    split(path) {\r\n        if (path === \"\")\r\n            return [];\r\n        if (!this.options.useSplitCache) {\r\n            return path.split(this.options.delimiter);\r\n        }\r\n        const fromCache = this.splitCache.get(path);\r\n        if (fromCache) {\r\n            return fromCache.slice();\r\n        }\r\n        const value = path.split(this.options.delimiter);\r\n        this.splitCache.set(path, value.slice());\r\n        return value;\r\n    }\r\n    isWildcard(path) {\r\n        return path.includes(this.options.wildcard) || this.hasParams(path);\r\n    }\r\n    isNotRecursive(path) {\r\n        return path.endsWith(this.options.notRecursive);\r\n    }\r\n    cleanNotRecursivePath(path) {\r\n        return this.isNotRecursive(path) ? path.substring(0, path.length - 1) : path;\r\n    }\r\n    hasParams(path) {\r\n        return path.includes(this.options.param);\r\n    }\r\n    getParamsInfo(path) {\r\n        let paramsInfo = { replaced: \"\", original: path, params: {} };\r\n        let partIndex = 0;\r\n        let fullReplaced = [];\r\n        for (const part of this.split(path)) {\r\n            paramsInfo.params[partIndex] = {\r\n                original: part,\r\n                replaced: \"\",\r\n                name: \"\",\r\n            };\r\n            const reg = new RegExp(`\\\\${this.options.param}([^\\\\${this.options.delimiter}\\\\${this.options.param}]+)`, \"g\");\r\n            let param = reg.exec(part);\r\n            if (param) {\r\n                paramsInfo.params[partIndex].name = param[1];\r\n            }\r\n            else {\r\n                delete paramsInfo.params[partIndex];\r\n                fullReplaced.push(part);\r\n                partIndex++;\r\n                continue;\r\n            }\r\n            reg.lastIndex = 0;\r\n            paramsInfo.params[partIndex].replaced = part.replace(reg, this.options.wildcard);\r\n            fullReplaced.push(paramsInfo.params[partIndex].replaced);\r\n            partIndex++;\r\n        }\r\n        paramsInfo.replaced = fullReplaced.join(this.options.delimiter);\r\n        return paramsInfo;\r\n    }\r\n    getParams(paramsInfo, path) {\r\n        if (!paramsInfo) {\r\n            return undefined;\r\n        }\r\n        const split = this.split(path);\r\n        const result = {};\r\n        for (const partIndex in paramsInfo.params) {\r\n            const param = paramsInfo.params[partIndex];\r\n            result[param.name] = split[partIndex];\r\n        }\r\n        return result;\r\n    }\r\n    waitForAll(userPaths, fn) {\r\n        const paths = {};\r\n        for (let path of userPaths) {\r\n            paths[path] = { dirty: false };\r\n            if (this.hasParams(path)) {\r\n                paths[path].paramsInfo = this.getParamsInfo(path);\r\n            }\r\n            paths[path].isWildcard = this.isWildcard(path);\r\n            paths[path].isRecursive = !this.isNotRecursive(path);\r\n        }\r\n        this.waitingListeners.set(userPaths, { fn, paths });\r\n        fn(paths);\r\n        return function unsubscribe() {\r\n            this.waitingListeners.delete(userPaths);\r\n        };\r\n    }\r\n    executeWaitingListeners(updatePath) {\r\n        if (this.destroyed)\r\n            return;\r\n        for (const waitingListener of this.waitingListeners.values()) {\r\n            const { fn, paths } = waitingListener;\r\n            let dirty = 0;\r\n            let all = 0;\r\n            for (let path in paths) {\r\n                const pathInfo = paths[path];\r\n                let match = false;\r\n                if (pathInfo.isRecursive)\r\n                    updatePath = this.cutPath(updatePath, path);\r\n                if (pathInfo.isWildcard && this.match(path, updatePath))\r\n                    match = true;\r\n                if (updatePath === path)\r\n                    match = true;\r\n                if (match) {\r\n                    pathInfo.dirty = true;\r\n                }\r\n                if (pathInfo.dirty) {\r\n                    dirty++;\r\n                }\r\n                all++;\r\n            }\r\n            if (dirty === all) {\r\n                fn(paths);\r\n            }\r\n        }\r\n    }\r\n    subscribeAll(userPaths, fn, options = this.getDefaultListenerOptions()) {\r\n        if (this.destroyed)\r\n            return () => { };\r\n        let unsubscribers = [];\r\n        let index = 0;\r\n        let groupId = null;\r\n        if (typeof options.group === \"boolean\" && options.group) {\r\n            this.groupId++;\r\n            groupId = this.groupId;\r\n            options.bulk = true;\r\n        }\r\n        else if (typeof options.group === \"string\") {\r\n            options.bulk = true;\r\n            groupId = options.group;\r\n        }\r\n        for (const userPath of userPaths) {\r\n            unsubscribers.push(this.subscribe(userPath, fn, options, {\r\n                all: userPaths,\r\n                index,\r\n                groupId,\r\n            }));\r\n            index++;\r\n        }\r\n        return function unsubscribe() {\r\n            for (const unsubscribe of unsubscribers) {\r\n                unsubscribe();\r\n            }\r\n        };\r\n    }\r\n    getCleanListenersCollection(values = {}) {\r\n        return Object.assign({ listeners: new Map(), isRecursive: false, isWildcard: false, hasParams: false, match: undefined, paramsInfo: undefined, path: undefined, originalPath: undefined, count: 0 }, values);\r\n    }\r\n    getCleanListener(fn, options = this.getDefaultListenerOptions()) {\r\n        return {\r\n            fn,\r\n            options: Object.assign(Object.assign({}, this.getDefaultListenerOptions()), options),\r\n            groupId: null,\r\n        };\r\n    }\r\n    getListenerCollectionMatch(listenerPath, isRecursive, isWildcard) {\r\n        listenerPath = this.cleanNotRecursivePath(listenerPath);\r\n        const self = this;\r\n        return function listenerCollectionMatch(path, debug = false) {\r\n            let scopedListenerPath = listenerPath;\r\n            if (isRecursive) {\r\n                path = self.cutPath(path, listenerPath);\r\n            }\r\n            else {\r\n                scopedListenerPath = self.cutPath(self.cleanNotRecursivePath(listenerPath), path);\r\n            }\r\n            if (debug) {\r\n                console.log(\"[getListenerCollectionMatch]\", {\r\n                    listenerPath,\r\n                    scopedListenerPath,\r\n                    path,\r\n                    isRecursive,\r\n                    isWildcard,\r\n                });\r\n            }\r\n            if (isWildcard && self.match(scopedListenerPath, path, isRecursive))\r\n                return true;\r\n            return scopedListenerPath === path;\r\n        };\r\n    }\r\n    getListenersCollection(listenerPath, listener) {\r\n        if (this.listeners.has(listenerPath)) {\r\n            let listenersCollection = this.listeners.get(listenerPath);\r\n            listenersCollection.listeners.set(++this.id, listener);\r\n            listener.id = this.id;\r\n            return listenersCollection;\r\n        }\r\n        const hasParams = this.hasParams(listenerPath);\r\n        let paramsInfo;\r\n        if (hasParams) {\r\n            paramsInfo = this.getParamsInfo(listenerPath);\r\n        }\r\n        let collCfg = {\r\n            isRecursive: !this.isNotRecursive(listenerPath),\r\n            isWildcard: this.isWildcard(listenerPath),\r\n            hasParams,\r\n            paramsInfo,\r\n            originalPath: listenerPath,\r\n            path: hasParams ? paramsInfo.replaced : listenerPath,\r\n        };\r\n        if (!collCfg.isRecursive) {\r\n            collCfg.path = this.cleanNotRecursivePath(collCfg.path);\r\n        }\r\n        let listenersCollection = this.getCleanListenersCollection(Object.assign(Object.assign({}, collCfg), { match: this.getListenerCollectionMatch(collCfg.path, collCfg.isRecursive, collCfg.isWildcard) }));\r\n        this.id++;\r\n        listenersCollection.listeners.set(this.id, listener);\r\n        listener.id = this.id;\r\n        this.listeners.set(collCfg.originalPath, listenersCollection);\r\n        return listenersCollection;\r\n    }\r\n    subscribe(listenerPath, fn, options = this.getDefaultListenerOptions(), subscribeAllOptions = {\r\n        all: [listenerPath],\r\n        index: 0,\r\n        groupId: null,\r\n    }) {\r\n        if (this.destroyed)\r\n            return () => { };\r\n        this.jobsRunning++;\r\n        const type = \"subscribe\";\r\n        let listener = this.getCleanListener(fn, options);\r\n        if (options.group) {\r\n            options.bulk = true;\r\n            if (typeof options.group === \"string\") {\r\n                listener.groupId = options.group;\r\n            }\r\n            else if (subscribeAllOptions.groupId) {\r\n                listener.groupId = subscribeAllOptions.groupId;\r\n            }\r\n        }\r\n        this.listenersIgnoreCache.set(listener, { truthy: [], falsy: [] });\r\n        const listenersCollection = this.getListenersCollection(listenerPath, listener);\r\n        if (options.debug) {\r\n            console.log(\"[subscribe]\", { listenerPath, options });\r\n        }\r\n        listenersCollection.count++;\r\n        let shouldFire = true;\r\n        if (listener.groupId) {\r\n            if (typeof listener.groupId === \"string\") {\r\n                if (this.namedGroups.includes(listener.groupId)) {\r\n                    shouldFire = false;\r\n                }\r\n                else {\r\n                    this.namedGroups.push(listener.groupId);\r\n                }\r\n            }\r\n            else if (typeof listener.groupId === \"number\") {\r\n                if (this.numberGroups.includes(listener.groupId)) {\r\n                    shouldFire = false;\r\n                }\r\n                else {\r\n                    this.numberGroups.push(listener.groupId);\r\n                }\r\n            }\r\n        }\r\n        if (shouldFire) {\r\n            const cleanPath = this.cleanNotRecursivePath(listenersCollection.path);\r\n            const cleanPathChunks = this.split(cleanPath);\r\n            if (!listenersCollection.isWildcard) {\r\n                if (!this.isMuted(cleanPath) && !this.isMuted(fn)) {\r\n                    fn(this.pathGet(cleanPathChunks, this.data), {\r\n                        type,\r\n                        listener,\r\n                        listenersCollection,\r\n                        path: {\r\n                            listener: listenerPath,\r\n                            update: undefined,\r\n                            resolved: this.cleanNotRecursivePath(listenerPath),\r\n                        },\r\n                        params: this.getParams(listenersCollection.paramsInfo, cleanPath),\r\n                        options,\r\n                    });\r\n                }\r\n            }\r\n            else {\r\n                const paths = this.scan.get(cleanPath);\r\n                if (options.bulk) {\r\n                    const bulkValue = [];\r\n                    for (const path in paths) {\r\n                        if (this.isMuted(path))\r\n                            continue;\r\n                        bulkValue.push({\r\n                            path,\r\n                            params: this.getParams(listenersCollection.paramsInfo, path),\r\n                            value: paths[path],\r\n                        });\r\n                    }\r\n                    if (!this.isMuted(fn)) {\r\n                        fn(bulkValue, {\r\n                            type,\r\n                            listener,\r\n                            listenersCollection,\r\n                            path: {\r\n                                listener: listenerPath,\r\n                                update: undefined,\r\n                                resolved: undefined,\r\n                            },\r\n                            options,\r\n                            params: undefined,\r\n                        });\r\n                    }\r\n                }\r\n                else {\r\n                    for (const path in paths) {\r\n                        if (!this.isMuted(path) && !this.isMuted(fn)) {\r\n                            fn(paths[path], {\r\n                                type,\r\n                                listener,\r\n                                listenersCollection,\r\n                                path: {\r\n                                    listener: listenerPath,\r\n                                    update: undefined,\r\n                                    resolved: this.cleanNotRecursivePath(path),\r\n                                },\r\n                                params: this.getParams(listenersCollection.paramsInfo, path),\r\n                                options,\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this.debugSubscribe(listener, listenersCollection, listenerPath);\r\n        this.jobsRunning--;\r\n        return this.unsubscribe(listenerPath, this.id);\r\n    }\r\n    unsubscribe(path, id) {\r\n        const listeners = this.listeners;\r\n        const listenersCollection = listeners.get(path);\r\n        return function unsub() {\r\n            listenersCollection.listeners.delete(id);\r\n            listenersCollection.count--;\r\n            if (listenersCollection.count === 0) {\r\n                listeners.delete(path);\r\n            }\r\n        };\r\n    }\r\n    runQueuedListeners() {\r\n        if (this.destroyed)\r\n            return;\r\n        if (this.subscribeQueue.length === 0)\r\n            return;\r\n        if (this.jobsRunning === 0) {\r\n            this.queueRuns = 0;\r\n            const queue = [...this.subscribeQueue];\r\n            for (let i = 0, len = queue.length; i < len; i++) {\r\n                queue[i]();\r\n            }\r\n            this.subscribeQueue.length = 0;\r\n        }\r\n        else {\r\n            this.queueRuns++;\r\n            if (this.queueRuns >= this.options.maxQueueRuns) {\r\n                this.queueRuns = 0;\r\n                throw new Error(\"Maximal number of queue runs exhausted.\");\r\n            }\r\n            else {\r\n                Promise.resolve()\r\n                    .then(() => this.runQueuedListeners())\r\n                    .catch((e) => {\r\n                    throw e;\r\n                });\r\n            }\r\n        }\r\n    }\r\n    getQueueNotifyListeners(groupedListeners, queue = []) {\r\n        for (const path in groupedListeners) {\r\n            if (this.isMuted(path))\r\n                continue;\r\n            let { single, bulk } = groupedListeners[path];\r\n            for (const singleListener of single) {\r\n                let alreadyInQueue = false;\r\n                let resolvedIdPath = singleListener.listener.id + \":\" + singleListener.eventInfo.path.resolved;\r\n                if (!singleListener.eventInfo.path.resolved) {\r\n                    resolvedIdPath = singleListener.listener.id + \":\" + singleListener.eventInfo.path.listener;\r\n                }\r\n                for (const excludedListener of queue) {\r\n                    if (resolvedIdPath === excludedListener.resolvedIdPath) {\r\n                        alreadyInQueue = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (alreadyInQueue) {\r\n                    continue;\r\n                }\r\n                const time = this.debugTime(singleListener);\r\n                if (!this.isMuted(singleListener.listener.fn)) {\r\n                    if (singleListener.listener.options.queue && this.jobsRunning) {\r\n                        this.subscribeQueue.push(() => {\r\n                            singleListener.listener.fn(singleListener.value ? singleListener.value() : undefined, singleListener.eventInfo);\r\n                        });\r\n                    }\r\n                    else {\r\n                        let resolvedIdPath = singleListener.listener.id + \":\" + singleListener.eventInfo.path.resolved;\r\n                        if (!singleListener.eventInfo.path.resolved) {\r\n                            resolvedIdPath = singleListener.listener.id + \":\" + singleListener.eventInfo.path.listener;\r\n                        }\r\n                        queue.push({\r\n                            id: singleListener.listener.id,\r\n                            resolvedPath: singleListener.eventInfo.path.resolved,\r\n                            resolvedIdPath,\r\n                            originalFn: singleListener.listener.fn,\r\n                            fn: () => {\r\n                                singleListener.listener.fn(singleListener.value ? singleListener.value() : undefined, singleListener.eventInfo);\r\n                            },\r\n                            options: singleListener.listener.options,\r\n                            groupId: singleListener.listener.groupId,\r\n                        });\r\n                    }\r\n                }\r\n                this.debugListener(time, singleListener);\r\n            }\r\n            for (const bulkListener of bulk) {\r\n                let alreadyInQueue = false;\r\n                for (const excludedListener of queue) {\r\n                    if (excludedListener.id === bulkListener.listener.id) {\r\n                        alreadyInQueue = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (alreadyInQueue)\r\n                    continue;\r\n                const time = this.debugTime(bulkListener);\r\n                const bulkValue = [];\r\n                for (const bulk of bulkListener.value) {\r\n                    bulkValue.push(Object.assign(Object.assign({}, bulk), { value: bulk.value ? bulk.value() : undefined }));\r\n                }\r\n                if (!this.isMuted(bulkListener.listener.fn)) {\r\n                    if (bulkListener.listener.options.queue && this.jobsRunning) {\r\n                        this.subscribeQueue.push(() => {\r\n                            if (!this.jobsRunning) {\r\n                                bulkListener.listener.fn(bulkValue, bulkListener.eventInfo);\r\n                                return true;\r\n                            }\r\n                            return false;\r\n                        });\r\n                    }\r\n                    else {\r\n                        let resolvedIdPath = bulkListener.listener.id + \":\" + bulkListener.eventInfo.path.resolved;\r\n                        if (!bulkListener.eventInfo.path.resolved) {\r\n                            resolvedIdPath = bulkListener.listener.id + \":\" + bulkListener.eventInfo.path.listener;\r\n                        }\r\n                        queue.push({\r\n                            id: bulkListener.listener.id,\r\n                            resolvedPath: bulkListener.eventInfo.path.resolved,\r\n                            resolvedIdPath,\r\n                            originalFn: bulkListener.listener.fn,\r\n                            fn: () => {\r\n                                bulkListener.listener.fn(bulkValue, bulkListener.eventInfo);\r\n                            },\r\n                            options: bulkListener.listener.options,\r\n                            groupId: bulkListener.listener.groupId,\r\n                        });\r\n                    }\r\n                }\r\n                this.debugListener(time, bulkListener);\r\n            }\r\n        }\r\n        Promise.resolve().then(() => this.runQueuedListeners());\r\n        return queue;\r\n    }\r\n    shouldIgnore(listener, updatePath) {\r\n        if (!listener.options.ignore)\r\n            return false;\r\n        for (const ignorePath of listener.options.ignore) {\r\n            if (updatePath.startsWith(ignorePath)) {\r\n                return true;\r\n            }\r\n            if (this.is_match && this.is_match(ignorePath, updatePath)) {\r\n                return true;\r\n            }\r\n            else {\r\n                const cuttedUpdatePath = this.cutPath(updatePath, ignorePath);\r\n                if (this.match(ignorePath, cuttedUpdatePath)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    getSubscribedListeners(updatePath, newValue, options, type = \"update\", originalPath = null) {\r\n        options = Object.assign(Object.assign({}, defaultUpdateOptions), options);\r\n        const listeners = {};\r\n        for (let [listenerPath, listenersCollection] of this.listeners) {\r\n            if (listenersCollection.match(updatePath)) {\r\n                listeners[listenerPath] = { single: [], bulk: [], bulkData: [] };\r\n                const params = listenersCollection.paramsInfo\r\n                    ? this.getParams(listenersCollection.paramsInfo, updatePath)\r\n                    : undefined;\r\n                const cutPath = this.cutPath(updatePath, listenerPath);\r\n                const traverse = listenersCollection.isRecursive || listenersCollection.isWildcard;\r\n                const value = traverse ? () => this.get(cutPath) : () => newValue;\r\n                const bulkValue = [{ value, path: updatePath, params }];\r\n                for (const listener of listenersCollection.listeners.values()) {\r\n                    if (this.shouldIgnore(listener, updatePath)) {\r\n                        if (listener.options.debug) {\r\n                            console.log(`[getSubscribedListeners] Listener was not fired because it was ignored.`, {\r\n                                listener,\r\n                                listenersCollection,\r\n                            });\r\n                        }\r\n                        continue;\r\n                    }\r\n                    if (listener.options.bulk) {\r\n                        listeners[listenerPath].bulk.push({\r\n                            listener,\r\n                            listenersCollection,\r\n                            eventInfo: {\r\n                                type,\r\n                                listener,\r\n                                path: {\r\n                                    listener: listenerPath,\r\n                                    update: originalPath ? originalPath : updatePath,\r\n                                    resolved: undefined,\r\n                                },\r\n                                params,\r\n                                options,\r\n                            },\r\n                            value: bulkValue,\r\n                        });\r\n                    }\r\n                    else {\r\n                        listeners[listenerPath].single.push({\r\n                            listener,\r\n                            listenersCollection,\r\n                            eventInfo: {\r\n                                type,\r\n                                listener,\r\n                                path: {\r\n                                    listener: listenerPath,\r\n                                    update: originalPath ? originalPath : updatePath,\r\n                                    resolved: this.cleanNotRecursivePath(updatePath),\r\n                                },\r\n                                params,\r\n                                options,\r\n                            },\r\n                            value,\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n            else if (this.options.extraDebug) {\r\n                // debug\r\n                let showMatch = false;\r\n                for (const listener of listenersCollection.listeners.values()) {\r\n                    if (listener.options.debug) {\r\n                        showMatch = true;\r\n                        console.log(`[getSubscribedListeners] Listener was not fired because there was no match.`, {\r\n                            listener,\r\n                            listenersCollection,\r\n                            updatePath,\r\n                        });\r\n                    }\r\n                }\r\n                if (showMatch) {\r\n                    listenersCollection.match(updatePath, true);\r\n                }\r\n            }\r\n        }\r\n        return listeners;\r\n    }\r\n    notifySubscribedListeners(updatePath, newValue, options, type = \"update\", originalPath = null) {\r\n        return this.getQueueNotifyListeners(this.getSubscribedListeners(updatePath, newValue, options, type, originalPath));\r\n    }\r\n    useBulkValue(listenersCollection) {\r\n        for (const [listenerId, listener] of listenersCollection.listeners) {\r\n            if (listener.options.bulk && listener.options.bulkValue)\r\n                return true;\r\n            if (!listener.options.bulk)\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n    getNestedListeners(updatePath, newValue, options, type = \"update\", originalPath = null) {\r\n        const listeners = {};\r\n        const restBelowValues = {};\r\n        for (let [listenerPath, listenersCollection] of this.listeners) {\r\n            if (!listenersCollection.isRecursive)\r\n                continue;\r\n            // listenerPath may be longer and is shortened - because we want to get listeners underneath change\r\n            const currentAbovePathCut = this.cutPath(listenerPath, updatePath);\r\n            if (this.match(currentAbovePathCut, updatePath)) {\r\n                listeners[listenerPath] = { single: [], bulk: [] };\r\n                // listener is listening below updated node\r\n                const restBelowPathCut = this.trimPath(listenerPath.substr(currentAbovePathCut.length));\r\n                const useBulkValue = this.useBulkValue(listenersCollection);\r\n                let wildcardNewValues;\r\n                if (useBulkValue) {\r\n                    wildcardNewValues = restBelowValues[restBelowPathCut]\r\n                        ? restBelowValues[restBelowPathCut] // if those values are already calculated use it\r\n                        : new WildcardObject(newValue, this.options.delimiter, this.options.wildcard).get(restBelowPathCut);\r\n                    restBelowValues[restBelowPathCut] = wildcardNewValues;\r\n                }\r\n                const params = listenersCollection.paramsInfo\r\n                    ? this.getParams(listenersCollection.paramsInfo, updatePath)\r\n                    : undefined;\r\n                const bulk = [];\r\n                const bulkListeners = {};\r\n                for (const [listenerId, listener] of listenersCollection.listeners) {\r\n                    if (useBulkValue) {\r\n                        for (const currentRestPath in wildcardNewValues) {\r\n                            const value = () => wildcardNewValues[currentRestPath];\r\n                            const fullPath = [updatePath, currentRestPath].join(this.options.delimiter);\r\n                            const eventInfo = {\r\n                                type,\r\n                                listener,\r\n                                listenersCollection,\r\n                                path: {\r\n                                    listener: listenerPath,\r\n                                    update: originalPath ? originalPath : updatePath,\r\n                                    resolved: this.cleanNotRecursivePath(fullPath),\r\n                                },\r\n                                params,\r\n                                options,\r\n                            };\r\n                            if (this.shouldIgnore(listener, updatePath))\r\n                                continue;\r\n                            if (listener.options.bulk) {\r\n                                bulk.push({ value, path: fullPath, params });\r\n                                bulkListeners[listenerId] = listener;\r\n                            }\r\n                            else {\r\n                                listeners[listenerPath].single.push({\r\n                                    listener,\r\n                                    listenersCollection,\r\n                                    eventInfo,\r\n                                    value,\r\n                                });\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        const eventInfo = {\r\n                            type,\r\n                            listener,\r\n                            listenersCollection,\r\n                            path: {\r\n                                listener: listenerPath,\r\n                                update: originalPath ? originalPath : updatePath,\r\n                                resolved: undefined,\r\n                            },\r\n                            params,\r\n                            options,\r\n                        };\r\n                        if (this.shouldIgnore(listener, updatePath))\r\n                            continue;\r\n                        if (listener.options.bulk) {\r\n                            bulk.push({ value: undefined, path: undefined, params });\r\n                            bulkListeners[listenerId] = listener;\r\n                        }\r\n                        else {\r\n                            listeners[listenerPath].single.push({\r\n                                listener,\r\n                                listenersCollection,\r\n                                eventInfo,\r\n                                value: undefined,\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n                for (const listenerId in bulkListeners) {\r\n                    const listener = bulkListeners[listenerId];\r\n                    const eventInfo = {\r\n                        type,\r\n                        listener,\r\n                        listenersCollection,\r\n                        path: {\r\n                            listener: listenerPath,\r\n                            update: updatePath,\r\n                            resolved: undefined,\r\n                        },\r\n                        options,\r\n                        params,\r\n                    };\r\n                    listeners[listenerPath].bulk.push({\r\n                        listener,\r\n                        listenersCollection,\r\n                        eventInfo,\r\n                        value: bulk,\r\n                    });\r\n                }\r\n            }\r\n            else if (this.options.extraDebug) {\r\n                // debug\r\n                for (const listener of listenersCollection.listeners.values()) {\r\n                    if (listener.options.debug) {\r\n                        console.log(\"[getNestedListeners] Listener was not fired because there was no match.\", {\r\n                            listener,\r\n                            listenersCollection,\r\n                            currentCutPath: currentAbovePathCut,\r\n                            updatePath,\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return listeners;\r\n    }\r\n    notifyNestedListeners(updatePath, newValue, options, type = \"update\", queue, originalPath = null) {\r\n        return this.getQueueNotifyListeners(this.getNestedListeners(updatePath, newValue, options, type, originalPath), queue);\r\n    }\r\n    getNotifyOnlyListeners(updatePath, newValue, options, type = \"update\", originalPath = null) {\r\n        const listeners = {};\r\n        if (typeof options.only !== \"object\" ||\r\n            !Array.isArray(options.only) ||\r\n            typeof options.only[0] === \"undefined\" ||\r\n            !this.canBeNested(newValue)) {\r\n            return listeners;\r\n        }\r\n        for (const notifyPath of options.only) {\r\n            const wildcardScanNewValue = new WildcardObject(newValue, this.options.delimiter, this.options.wildcard).get(notifyPath);\r\n            listeners[notifyPath] = { bulk: [], single: [] };\r\n            for (const wildcardPath in wildcardScanNewValue) {\r\n                const fullPath = updatePath + this.options.delimiter + wildcardPath;\r\n                for (const [listenerPath, listenersCollection] of this.listeners) {\r\n                    const params = listenersCollection.paramsInfo\r\n                        ? this.getParams(listenersCollection.paramsInfo, fullPath)\r\n                        : undefined;\r\n                    if (this.match(listenerPath, fullPath)) {\r\n                        const value = () => wildcardScanNewValue[wildcardPath];\r\n                        const bulkValue = [{ value, path: fullPath, params }];\r\n                        for (const listener of listenersCollection.listeners.values()) {\r\n                            const eventInfo = {\r\n                                type,\r\n                                listener,\r\n                                listenersCollection,\r\n                                path: {\r\n                                    listener: listenerPath,\r\n                                    update: originalPath ? originalPath : updatePath,\r\n                                    resolved: this.cleanNotRecursivePath(fullPath),\r\n                                },\r\n                                params,\r\n                                options,\r\n                            };\r\n                            if (this.shouldIgnore(listener, updatePath))\r\n                                continue;\r\n                            if (listener.options.bulk) {\r\n                                if (!listeners[notifyPath].bulk.some((bulkListener) => bulkListener.listener === listener)) {\r\n                                    listeners[notifyPath].bulk.push({\r\n                                        listener,\r\n                                        listenersCollection,\r\n                                        eventInfo,\r\n                                        value: bulkValue,\r\n                                    });\r\n                                }\r\n                            }\r\n                            else {\r\n                                listeners[notifyPath].single.push({\r\n                                    listener,\r\n                                    listenersCollection,\r\n                                    eventInfo,\r\n                                    value,\r\n                                });\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return listeners;\r\n    }\r\n    runQueue(queue) {\r\n        const firedGroups = [];\r\n        for (const q of queue) {\r\n            if (q.options.group) {\r\n                if (!firedGroups.includes(q.groupId)) {\r\n                    q.fn();\r\n                    firedGroups.push(q.groupId);\r\n                }\r\n            }\r\n            else {\r\n                q.fn();\r\n            }\r\n        }\r\n    }\r\n    sortAndRunQueue(queue, path) {\r\n        queue.sort(function (a, b) {\r\n            return a.id - b.id;\r\n        });\r\n        if (this.options.debug) {\r\n            console.log(`[deep-state-observer] queue for ${path}`, queue);\r\n        }\r\n        this.runQueue(queue);\r\n    }\r\n    notifyOnly(updatePath, newValue, options, type = \"update\", originalPath = \"\") {\r\n        const queue = this.getQueueNotifyListeners(this.getNotifyOnlyListeners(updatePath, newValue, options, type, originalPath));\r\n        this.sortAndRunQueue(queue, updatePath);\r\n    }\r\n    canBeNested(newValue) {\r\n        return typeof newValue === \"object\" && newValue !== null;\r\n    }\r\n    getUpdateValues(oldValue, fn) {\r\n        let newValue = fn;\r\n        if (typeof fn === \"function\") {\r\n            newValue = fn(oldValue);\r\n        }\r\n        return { newValue, oldValue };\r\n    }\r\n    wildcardNotify(groupedListenersPack, waitingPaths) {\r\n        let queue = [];\r\n        for (const groupedListeners of groupedListenersPack) {\r\n            this.getQueueNotifyListeners(groupedListeners, queue);\r\n        }\r\n        for (const path of waitingPaths) {\r\n            this.executeWaitingListeners(path);\r\n        }\r\n        this.jobsRunning--;\r\n        return queue;\r\n    }\r\n    wildcardUpdate(updatePath, fn, options = defaultUpdateOptions, multi = false) {\r\n        ++this.jobsRunning;\r\n        options = Object.assign(Object.assign({}, defaultUpdateOptions), options);\r\n        const scanned = this.scan.get(updatePath);\r\n        const updated = {};\r\n        for (const path in scanned) {\r\n            const split = this.split(path);\r\n            const { oldValue, newValue } = this.getUpdateValues(scanned[path], fn);\r\n            if (!this.same(newValue, oldValue) || options.force) {\r\n                this.pathSet(split, newValue, this.data);\r\n                updated[path] = newValue;\r\n            }\r\n        }\r\n        const groupedListenersPack = [];\r\n        const waitingPaths = [];\r\n        for (const path in updated) {\r\n            const newValue = updated[path];\r\n            if (options.only.length) {\r\n                groupedListenersPack.push(this.getNotifyOnlyListeners(path, newValue, options, \"update\", updatePath));\r\n            }\r\n            else {\r\n                groupedListenersPack.push(this.getSubscribedListeners(path, newValue, options, \"update\", updatePath));\r\n                if (this.canBeNested(newValue)) {\r\n                    groupedListenersPack.push(this.getNestedListeners(path, newValue, options, \"update\", updatePath));\r\n                }\r\n            }\r\n            options.debug && this.options.log(\"Wildcard update\", { path, newValue });\r\n            waitingPaths.push(path);\r\n        }\r\n        if (multi) {\r\n            const self = this;\r\n            return function () {\r\n                const queue = self.wildcardNotify(groupedListenersPack, waitingPaths);\r\n                self.sortAndRunQueue(queue, updatePath);\r\n            };\r\n        }\r\n        const queue = this.wildcardNotify(groupedListenersPack, waitingPaths);\r\n        this.sortAndRunQueue(queue, updatePath);\r\n    }\r\n    runUpdateQueue() {\r\n        if (this.destroyed)\r\n            return;\r\n        while (this.updateQueue.length && this.updateQueue.length < this.options.maxSimultaneousJobs) {\r\n            const params = this.updateQueue.shift();\r\n            params.options.queue = false; // prevent infinite loop\r\n            this.update(params.updatePath, params.fnOrValue, params.options, params.multi);\r\n        }\r\n    }\r\n    updateNotify(updatePath, newValue, options) {\r\n        const queue = this.notifySubscribedListeners(updatePath, newValue, options);\r\n        if (this.canBeNested(newValue)) {\r\n            this.notifyNestedListeners(updatePath, newValue, options, \"update\", queue);\r\n        }\r\n        this.sortAndRunQueue(queue, updatePath);\r\n        this.executeWaitingListeners(updatePath);\r\n    }\r\n    updateNotifyAll(updateStack) {\r\n        let queue = [];\r\n        for (const current of updateStack) {\r\n            const value = current.newValue;\r\n            if (this.tracing.length) {\r\n                const traceId = this.tracing[this.tracing.length - 1];\r\n                const trace = this.traceMap.get(traceId);\r\n                trace.changed.push({\r\n                    traceId,\r\n                    updatePath: current.updatePath,\r\n                    fnOrValue: value,\r\n                    options: current.options,\r\n                });\r\n                this.traceMap.set(traceId, trace);\r\n            }\r\n            queue = queue.concat(this.notifySubscribedListeners(current.updatePath, value, current.options));\r\n            if (this.canBeNested(current.newValue)) {\r\n                this.notifyNestedListeners(current.updatePath, value, current.options, \"update\", queue);\r\n            }\r\n        }\r\n        this.runQueue(queue);\r\n    }\r\n    updateNotifyOnly(updatePath, newValue, options) {\r\n        this.notifyOnly(updatePath, newValue, options);\r\n        this.executeWaitingListeners(updatePath);\r\n    }\r\n    update(updatePath, fnOrValue, options = Object.assign({}, defaultUpdateOptions), multi = false) {\r\n        if (this.destroyed)\r\n            return;\r\n        if (this.collection) {\r\n            return this.collection.update(updatePath, fnOrValue, options);\r\n        }\r\n        if (this.tracing.length) {\r\n            const traceId = this.tracing[this.tracing.length - 1];\r\n            const trace = this.traceMap.get(traceId);\r\n            trace.changed.push({ traceId, updatePath, fnOrValue, options });\r\n            this.traceMap.set(traceId, trace);\r\n        }\r\n        const jobsRunning = this.jobsRunning;\r\n        if ((this.options.queue || options.queue) && jobsRunning) {\r\n            if (jobsRunning > this.options.maxSimultaneousJobs) {\r\n                throw new Error(\"Maximal simultaneous jobs limit reached.\");\r\n            }\r\n            this.updateQueue.push({ updatePath, fnOrValue, options, multi });\r\n            const result = Promise.resolve().then(() => {\r\n                this.runUpdateQueue();\r\n            });\r\n            if (multi) {\r\n                return function () {\r\n                    return result;\r\n                };\r\n            }\r\n            return result;\r\n        }\r\n        if (this.isWildcard(updatePath)) {\r\n            return this.wildcardUpdate(updatePath, fnOrValue, options, multi);\r\n        }\r\n        ++this.jobsRunning;\r\n        const split = this.split(updatePath);\r\n        const currentValue = this.pathGet(split, this.data);\r\n        let { oldValue, newValue } = this.getUpdateValues(currentValue, fnOrValue);\r\n        if (options.debug) {\r\n            this.options.log(`Updating ${updatePath} ${options.source ? `from ${options.source}` : \"\"}`, {\r\n                oldValue,\r\n                newValue,\r\n            });\r\n        }\r\n        if (this.same(newValue, oldValue) && !options.force) {\r\n            --this.jobsRunning;\r\n            if (multi)\r\n                return function () {\r\n                    return newValue;\r\n                };\r\n            return newValue;\r\n        }\r\n        this.pathSet(split, newValue, this.data);\r\n        options = Object.assign(Object.assign({}, defaultUpdateOptions), options);\r\n        if (options.only === null) {\r\n            --this.jobsRunning;\r\n            if (multi)\r\n                return function () { };\r\n            return newValue;\r\n        }\r\n        if (options.only.length) {\r\n            --this.jobsRunning;\r\n            if (multi) {\r\n                const self = this;\r\n                return function () {\r\n                    const result = self.updateNotifyOnly(updatePath, newValue, options);\r\n                    return result;\r\n                };\r\n            }\r\n            this.updateNotifyOnly(updatePath, newValue, options);\r\n            return newValue;\r\n        }\r\n        if (multi) {\r\n            --this.jobsRunning;\r\n            const self = this;\r\n            return function multiUpdate() {\r\n                const result = self.updateNotify(updatePath, newValue, options);\r\n                return result;\r\n            };\r\n        }\r\n        this.updateNotify(updatePath, newValue, options);\r\n        --this.jobsRunning;\r\n        return newValue;\r\n    }\r\n    multi(grouped = false) {\r\n        if (this.destroyed)\r\n            return {\r\n                update() {\r\n                    return this;\r\n                },\r\n                done() { },\r\n                getStack() {\r\n                    return [];\r\n                },\r\n            };\r\n        if (this.collection)\r\n            return this.collection;\r\n        const self = this;\r\n        const updateStack = [];\r\n        const notifiers = [];\r\n        const multiObject = {\r\n            update(updatePath, fnOrValue, options = defaultUpdateOptions) {\r\n                if (grouped) {\r\n                    const split = self.split(updatePath);\r\n                    let value = fnOrValue;\r\n                    const currentValue = self.pathGet(split, self.data);\r\n                    if (typeof value === \"function\") {\r\n                        value = value(currentValue);\r\n                    }\r\n                    self.pathSet(split, value, self.data);\r\n                    updateStack.push({ updatePath, newValue: value, options });\r\n                }\r\n                else {\r\n                    notifiers.push(self.update(updatePath, fnOrValue, options, true));\r\n                }\r\n                return this;\r\n            },\r\n            done() {\r\n                if (self.collections !== 0) {\r\n                    return;\r\n                }\r\n                if (grouped) {\r\n                    self.updateNotifyAll(updateStack);\r\n                }\r\n                else {\r\n                    for (const current of notifiers) {\r\n                        current();\r\n                    }\r\n                }\r\n                updateStack.length = 0;\r\n            },\r\n            getStack() {\r\n                return updateStack;\r\n            },\r\n        };\r\n        return multiObject;\r\n    }\r\n    collect() {\r\n        this.collections++;\r\n        if (!this.collection) {\r\n            this.collection = this.multi(true);\r\n        }\r\n        return this.collection;\r\n    }\r\n    executeCollected() {\r\n        this.collections--;\r\n        if (this.collections === 0 && this.collection) {\r\n            const collection = this.collection;\r\n            this.collection = null;\r\n            collection.done();\r\n        }\r\n    }\r\n    getCollectedCount() {\r\n        return this.collections;\r\n    }\r\n    getCollectedStack() {\r\n        if (!this.collection)\r\n            return [];\r\n        return this.collection.getStack();\r\n    }\r\n    get(userPath = undefined) {\r\n        if (this.destroyed)\r\n            return;\r\n        if (userPath === undefined || userPath === \"\") {\r\n            return this.data;\r\n        }\r\n        if (this.isWildcard(userPath)) {\r\n            return this.scan.get(userPath);\r\n        }\r\n        return this.pathGet(this.split(userPath), this.data);\r\n    }\r\n    last(callback) {\r\n        let last = this.lastExecs.get(callback);\r\n        if (!last) {\r\n            last = { calls: 0 };\r\n            this.lastExecs.set(callback, last);\r\n        }\r\n        const current = ++last.calls;\r\n        this.resolved.then(() => {\r\n            if (current === last.calls) {\r\n                this.lastExecs.set(callback, { calls: 0 });\r\n                callback();\r\n            }\r\n        });\r\n    }\r\n    isMuted(pathOrListenerFunction) {\r\n        if (!this.options.useMute)\r\n            return false;\r\n        if (typeof pathOrListenerFunction === \"function\") {\r\n            return this.isMutedListener(pathOrListenerFunction);\r\n        }\r\n        for (const mutedPath of this.muted) {\r\n            const recursive = !this.isNotRecursive(mutedPath);\r\n            const trimmedMutedPath = this.trimPath(mutedPath);\r\n            if (this.match(pathOrListenerFunction, trimmedMutedPath))\r\n                return true;\r\n            if (this.match(trimmedMutedPath, pathOrListenerFunction))\r\n                return true;\r\n            if (recursive) {\r\n                const cutPath = this.cutPath(trimmedMutedPath, pathOrListenerFunction);\r\n                if (this.match(cutPath, mutedPath))\r\n                    return true;\r\n                if (this.match(mutedPath, cutPath))\r\n                    return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    isMutedListener(listenerFunc) {\r\n        return this.mutedListeners.has(listenerFunc);\r\n    }\r\n    mute(pathOrListenerFunction) {\r\n        if (typeof pathOrListenerFunction === \"function\") {\r\n            return this.mutedListeners.add(pathOrListenerFunction);\r\n        }\r\n        this.muted.add(pathOrListenerFunction);\r\n    }\r\n    unmute(pathOrListenerFunction) {\r\n        if (typeof pathOrListenerFunction === \"function\") {\r\n            return this.mutedListeners.delete(pathOrListenerFunction);\r\n        }\r\n        this.muted.delete(pathOrListenerFunction);\r\n    }\r\n    debugSubscribe(listener, listenersCollection, listenerPath) {\r\n        if (listener.options.debug) {\r\n            this.options.log(\"listener subscribed\", {\r\n                listenerPath,\r\n                listener,\r\n                listenersCollection,\r\n            });\r\n        }\r\n    }\r\n    debugListener(time, groupedListener) {\r\n        if (groupedListener.eventInfo.options.debug || groupedListener.listener.options.debug) {\r\n            this.options.log(\"Listener fired\", {\r\n                time: Date.now() - time,\r\n                info: groupedListener,\r\n            });\r\n        }\r\n    }\r\n    debugTime(groupedListener) {\r\n        return groupedListener.listener.options.debug || groupedListener.eventInfo.options.debug ? Date.now() : 0;\r\n    }\r\n    startTrace(name, additionalData = null) {\r\n        this.traceId++;\r\n        const id = this.traceId + \":\" + name;\r\n        this.traceMap.set(id, {\r\n            id,\r\n            sort: this.traceId,\r\n            stack: this.tracing.map((i) => i),\r\n            additionalData,\r\n            changed: [],\r\n        });\r\n        this.tracing.push(id);\r\n        return id;\r\n    }\r\n    stopTrace(id) {\r\n        const result = this.traceMap.get(id);\r\n        this.tracing.pop();\r\n        this.traceMap.delete(id);\r\n        return result;\r\n    }\r\n    saveTrace(id) {\r\n        const result = this.traceMap.get(id);\r\n        this.tracing.pop();\r\n        this.traceMap.delete(id);\r\n        this.savedTrace.push(result);\r\n        return result;\r\n    }\r\n    getSavedTraces() {\r\n        const savedTrace = this.savedTrace.map((trace) => trace);\r\n        savedTrace.sort((a, b) => {\r\n            return a.sort - b.sort;\r\n        });\r\n        this.savedTrace = [];\r\n        return savedTrace;\r\n    }\r\n}\n\nexport { DeepState as default };\n","var NodeType = /* @__PURE__ */ ((NodeType2) => {\n  NodeType2[\"CONTAINER\"] = \"container\";\n  NodeType2[\"PAGE\"] = \"page\";\n  NodeType2[\"ROOT\"] = \"app\";\n  NodeType2[\"PAGE_FRAGMENT\"] = \"page-fragment\";\n  return NodeType2;\n})(NodeType || {});\nconst NODE_CONDS_KEY = \"displayConds\";\nconst NODE_DISABLE_DATA_SOURCE_KEY = \"_tmagic_node_disabled_data_source\";\nconst NODE_DISABLE_CODE_BLOCK_KEY = \"_tmagic_node_disabled_code_block\";\nvar ActionType = /* @__PURE__ */ ((ActionType2) => {\n  ActionType2[\"COMP\"] = \"comp\";\n  ActionType2[\"CODE\"] = \"code\";\n  ActionType2[\"DATA_SOURCE\"] = \"data-source\";\n  return ActionType2;\n})(ActionType || {});\nvar HookType = /* @__PURE__ */ ((HookType2) => {\n  HookType2[\"CODE\"] = \"code\";\n  return HookType2;\n})(HookType || {});\nvar HookCodeType = /* @__PURE__ */ ((HookCodeType2) => {\n  HookCodeType2[\"CODE\"] = \"code\";\n  HookCodeType2[\"DATA_SOURCE_METHOD\"] = \"data-source-method\";\n  return HookCodeType2;\n})(HookCodeType || {});\n\nexport { ActionType, HookCodeType, HookType, NODE_CONDS_KEY, NODE_DISABLE_CODE_BLOCK_KEY, NODE_DISABLE_DATA_SOURCE_KEY, NodeType };\n","import { set, cloneDeep } from 'lodash-es';\nimport { NodeType } from '@tmagic/schema';\n\nconst asyncLoadJs = /* @__PURE__ */ (() => {\n  const documentMap = /* @__PURE__ */ new Map();\n  return (url, crossOrigin, document = globalThis.document) => {\n    let loaded = documentMap.get(document);\n    if (!loaded) {\n      loaded = /* @__PURE__ */ new Map();\n      documentMap.set(document, loaded);\n    }\n    if (loaded.get(url)) return loaded.get(url);\n    const load = new Promise((resolve, reject) => {\n      const script = document.createElement(\"script\");\n      script.type = \"text/javascript\";\n      if (crossOrigin) {\n        script.crossOrigin = crossOrigin;\n      }\n      script.src = url;\n      document.body.appendChild(script);\n      script.onload = () => {\n        resolve();\n      };\n      script.onerror = () => {\n        reject(new Error(\"加载失败\"));\n      };\n      setTimeout(() => {\n        reject(new Error(\"timeout\"));\n      }, 60 * 1e3);\n    }).catch((err) => {\n      loaded.delete(url);\n      throw err;\n    });\n    loaded.set(url, load);\n    return loaded.get(url);\n  };\n})();\nconst asyncLoadCss = /* @__PURE__ */ (() => {\n  const documentMap = /* @__PURE__ */ new Map();\n  return (url, document = globalThis.document) => {\n    let loaded = documentMap.get(document);\n    if (!loaded) {\n      loaded = /* @__PURE__ */ new Map();\n      documentMap.set(document, loaded);\n    }\n    if (loaded.get(url)) return loaded.get(url);\n    const load = new Promise((resolve, reject) => {\n      const node = document.createElement(\"link\");\n      node.rel = \"stylesheet\";\n      node.href = url;\n      document.head.appendChild(node);\n      node.onload = () => {\n        resolve();\n      };\n      node.onerror = () => {\n        reject(new Error(\"加载失败\"));\n      };\n      setTimeout(() => {\n        reject(new Error(\"timeout\"));\n      }, 60 * 1e3);\n    }).catch((err) => {\n      loaded.delete(url);\n      throw err;\n    });\n    loaded.set(url, load);\n    return loaded.get(url);\n  };\n})();\nconst addClassName = (el, doc, className) => {\n  const oldEl = doc.querySelector(`.${className}`);\n  if (oldEl && oldEl !== el) removeClassName(oldEl, className);\n  if (!el.classList.contains(className)) el.classList.add(className);\n};\nconst removeClassName = (el, ...className) => {\n  el.classList.remove(...className);\n};\nconst removeClassNameByClassName = (doc, className) => {\n  const el = doc.querySelector(`.${className}`);\n  el?.classList.remove(className);\n  return el;\n};\nconst injectStyle = (doc, style) => {\n  const styleEl = doc.createElement(\"style\");\n  styleEl.innerHTML = style;\n  doc.head.appendChild(styleEl);\n  return styleEl;\n};\nconst createDiv = ({ className, cssText }) => {\n  const el = globalThis.document.createElement(\"div\");\n  el.className = className;\n  el.style.cssText = cssText;\n  return el;\n};\nconst getDocument = () => globalThis.document;\nconst calcValueByFontsize = (doc, value) => {\n  if (!doc) return value;\n  const { fontSize } = doc.documentElement.style;\n  if (fontSize) {\n    const times = globalThis.parseFloat(fontSize) / 100;\n    return Number((value / times).toFixed(2));\n  }\n  return value;\n};\nconst dslDomRelateConfig = {\n  getIdFromEl: (el) => el?.dataset?.tmagicId,\n  getElById: (doc, id) => doc?.querySelector(`[data-tmagic-id=\"${id}\"]`),\n  setIdToEl: (el, id) => {\n    el.dataset.tmagicId = `${id}`;\n  }\n};\nconst setDslDomRelateConfig = (name, value) => {\n  dslDomRelateConfig[name] = value;\n};\nconst getIdFromEl = () => dslDomRelateConfig.getIdFromEl;\nconst getElById = () => dslDomRelateConfig.getElById;\nconst setIdToEl = () => dslDomRelateConfig.setIdToEl;\n\nlet _globalThis;\nconst getGlobalThis = () => _globalThis || (_globalThis = typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : {});\nconst sleep = (ms) => new Promise((resolve) => {\n  const timer = setTimeout(() => {\n    clearTimeout(timer);\n    resolve();\n  }, ms);\n});\nconst toLine = (name = \"\") => name.replace(/\\B([A-Z])/g, \"-$1\").toLowerCase();\nconst toHump = (name = \"\") => name.replace(/-(\\w)/g, (_all, letter) => letter.toUpperCase());\nconst emptyFn = () => void 0;\nconst getNodePath = (id, data = []) => {\n  const path = [];\n  const get = function(id2, data2) {\n    if (!Array.isArray(data2)) {\n      return null;\n    }\n    for (let i = 0, l = data2.length; i < l; i++) {\n      const item = data2[i];\n      path.push(item);\n      if (`${item.id}` === `${id2}`) {\n        return item;\n      }\n      if (item.items) {\n        const node = get(id2, item.items);\n        if (node) {\n          return node;\n        }\n      }\n      path.pop();\n    }\n    return null;\n  };\n  get(id, data);\n  return path;\n};\nconst getNodeInfo = (id, root) => {\n  const info = {\n    node: null,\n    parent: null,\n    page: null\n  };\n  if (!root) return info;\n  if (id === root.id) {\n    info.node = root;\n    return info;\n  }\n  const path = getNodePath(id, root.items);\n  if (!path.length) return info;\n  path.unshift(root);\n  info.node = path[path.length - 1];\n  info.parent = path[path.length - 2];\n  path.forEach((item) => {\n    if (isPage(item) || isPageFragment(item)) {\n      info.page = item;\n      return;\n    }\n  });\n  return info;\n};\nconst filterXSS = (str) => str.replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\").replace(/\"/g, \"&quot;\").replace(/'/g, \"&apos;\");\nconst getUrlParam = (param, url) => {\n  const u = url || location.href;\n  const reg = new RegExp(`[?&#]${param}=([^&#]+)`, \"gi\");\n  const matches = u.match(reg);\n  let strArr;\n  if (matches && matches.length > 0) {\n    strArr = matches[matches.length - 1].split(\"=\");\n    if (strArr && strArr.length > 1) {\n      return filterXSS(strArr[1]);\n    }\n    return \"\";\n  }\n  return \"\";\n};\nconst setUrlParam = (name, value, url = globalThis.location.href) => {\n  const reg = new RegExp(`[?&#]${name}=([^&#]*)`, \"gi\");\n  const matches = url.match(reg);\n  const key = `{key${(/* @__PURE__ */ new Date()).getTime()}}`;\n  let strArr;\n  if (matches && matches.length > 0) {\n    strArr = matches[matches.length - 1];\n  } else {\n    strArr = \"\";\n  }\n  const extra = `${name}=${value}`;\n  if (strArr) {\n    const first = strArr.charAt(0);\n    url = url.replace(strArr, key);\n    url = url.replace(key, value ? first + extra : \"\");\n  } else if (value) {\n    if (url.indexOf(\"?\") > -1) {\n      url += `&${extra}`;\n    } else {\n      url += `?${extra}`;\n    }\n  }\n  return url;\n};\nconst getSearchObj = (search = globalThis.location.search ? globalThis.location.search.substring(1) : \"\") => {\n  return search.split(\"&\").reduce((obj, item) => {\n    const [a, b = \"\"] = item.split(\"=\");\n    return { ...obj, [a]: b };\n  }, {});\n};\nconst delQueStr = (url, ref) => {\n  let str = \"\";\n  if (url.indexOf(\"?\") !== -1) {\n    str = url.substring(url.indexOf(\"?\") + 1);\n  } else {\n    return url;\n  }\n  let arr = [];\n  let returnurl = \"\";\n  const isHit = Array.isArray(ref) ? function(v) {\n    return ~ref.indexOf(v);\n  } : function(v) {\n    return v === ref;\n  };\n  if (str.indexOf(\"&\") !== -1) {\n    arr = str.split(\"&\");\n    for (let i = 0, len = arr.length; i < len; i++) {\n      if (!isHit(arr[i].split(\"=\")[0])) {\n        returnurl = `${returnurl + arr[i].split(\"=\")[0]}=${arr[i].split(\"=\")[1]}&`;\n      }\n    }\n    return returnurl ? `${url.substr(0, url.indexOf(\"?\"))}?${returnurl.substr(0, returnurl.length - 1)}` : url.substr(0, url.indexOf(\"?\"));\n  }\n  arr = str.split(\"=\");\n  if (isHit(arr[0])) {\n    return url.substr(0, url.indexOf(\"?\"));\n  }\n  return url;\n};\nconst isObject = (obj) => Object.prototype.toString.call(obj) === \"[object Object]\";\nconst isPop = (node) => Boolean(node?.type?.toLowerCase().endsWith(\"pop\"));\nconst isPage = (node) => {\n  if (!node) return false;\n  return Boolean(node.type?.toLowerCase() === NodeType.PAGE);\n};\nconst isPageFragment = (node) => {\n  if (!node) return false;\n  return Boolean(node.type?.toLowerCase() === NodeType.PAGE_FRAGMENT);\n};\nconst isNumber = (value) => /^(-?\\d+)(\\.\\d+)?$/.test(value);\nconst getHost = (targetUrl) => targetUrl.match(/\\/\\/([^/]+)/)?.[1];\nconst isSameDomain = (targetUrl = \"\", source = globalThis.location.host) => {\n  const isHttpUrl = /^(http[s]?:)?\\/\\//.test(targetUrl);\n  if (!isHttpUrl) return true;\n  return getHost(targetUrl) === source;\n};\nconst guid = (digit = 8) => \"x\".repeat(digit).replace(/[xy]/g, (c) => {\n  const r = Math.random() * 16 | 0;\n  const v = c === \"x\" ? r : r & 3 | 8;\n  return v.toString(16);\n});\nconst getKeysArray = (keys) => (\n  // 将 array[0] 转成 array.0\n  `${keys}`.replace(/\\[(\\d+)\\]/g, \".$1\").split(\".\")\n);\nconst getValueByKeyPath = (keys = \"\", data = {}) => {\n  const keyArray = Array.isArray(keys) ? keys : getKeysArray(keys);\n  return keyArray.reduce((accumulator, currentValue) => {\n    if (isObject(accumulator)) {\n      return accumulator[currentValue];\n    }\n    if (Array.isArray(accumulator) && /^\\d*$/.test(`${currentValue}`)) {\n      return accumulator[currentValue];\n    }\n    throw new Error(`${data}中不存在${keys}`);\n  }, data);\n};\nconst setValueByKeyPath = (keys, value, data = {}) => set(data, keys, value);\nconst getNodes = (ids, data = []) => {\n  const nodes = [];\n  const get = function(ids2, data2) {\n    if (!Array.isArray(data2)) {\n      return;\n    }\n    for (const item of data2) {\n      const index = ids2.findIndex((id) => `${id}` === `${item.id}`);\n      if (index > -1) {\n        ids2.splice(index, 1);\n        nodes.push(item);\n      }\n      if (item.items) {\n        get(ids2, item.items);\n      }\n    }\n  };\n  get(ids, data);\n  return nodes;\n};\nconst getDepKeys = (dataSourceDeps = {}, nodeId) => Array.from(\n  Object.values(dataSourceDeps).reduce((prev, cur) => {\n    (cur[nodeId]?.keys || []).forEach((key) => prev.add(key));\n    return prev;\n  }, /* @__PURE__ */ new Set())\n);\nconst getDepNodeIds = (dataSourceDeps = {}) => Array.from(\n  Object.values(dataSourceDeps).reduce((prev, cur) => {\n    Object.keys(cur).forEach((id) => {\n      prev.add(id);\n    });\n    return prev;\n  }, /* @__PURE__ */ new Set())\n);\nconst replaceChildNode = (newNode, data, parentId) => {\n  const path = getNodePath(newNode.id, data);\n  const node = path.pop();\n  let parent = path.pop();\n  if (parentId) {\n    parent = getNodePath(parentId, data).pop();\n  }\n  if (!node) {\n    console.warn(`未找到目标节点(${newNode.id})`);\n    return;\n  }\n  if (!parent) {\n    console.warn(`未找到父节点(${newNode.id})`);\n    return;\n  }\n  const index = parent.items?.findIndex((child) => child.id === node.id);\n  parent.items.splice(index, 1, newNode);\n};\nconst DSL_NODE_KEY_COPY_PREFIX = \"__tmagic__\";\nconst IS_DSL_NODE_KEY = \"__tmagic__dslNode\";\nconst PAGE_FRAGMENT_CONTAINER_ID_KEY = \"tmagic-page-fragment-container-id\";\nconst compiledNode = (compile, node, dataSourceDeps = {}, sourceId) => {\n  let keys = [];\n  if (!sourceId) {\n    keys = getDepKeys(dataSourceDeps, node.id);\n  } else {\n    const dep = dataSourceDeps[sourceId];\n    keys = dep?.[node.id].keys || [];\n  }\n  keys.forEach((key) => {\n    const keys2 = getKeysArray(key);\n    const cacheKey = keys2.map((key2, index) => {\n      if (index < keys2.length - 1) {\n        return key2;\n      }\n      return `${DSL_NODE_KEY_COPY_PREFIX}${key2}`;\n    });\n    let templateValue = getValueByKeyPath(cacheKey, node);\n    if (typeof templateValue === \"undefined\") {\n      try {\n        const value = getValueByKeyPath(key, node);\n        setValueByKeyPath(cacheKey.join(\".\"), value, node);\n        templateValue = value;\n      } catch (e) {\n        console.warn(e);\n        return;\n      }\n    }\n    let newValue;\n    try {\n      newValue = compile(templateValue);\n    } catch (e) {\n      console.error(e);\n      newValue = \"\";\n    }\n    setValueByKeyPath(key, newValue, node);\n  });\n  return node;\n};\nconst compiledCond = (op, fieldValue, inputValue, range = []) => {\n  if (typeof fieldValue === \"string\" && typeof inputValue === \"undefined\") {\n    inputValue = \"\";\n  }\n  switch (op) {\n    case \"is\":\n      return fieldValue === inputValue;\n    case \"not\":\n      return fieldValue !== inputValue;\n    case \"=\":\n      return fieldValue === inputValue;\n    case \"!=\":\n      return fieldValue !== inputValue;\n    case \">\":\n      return fieldValue > inputValue;\n    case \">=\":\n      return fieldValue >= inputValue;\n    case \"<\":\n      return fieldValue < inputValue;\n    case \"<=\":\n      return fieldValue <= inputValue;\n    case \"between\":\n      return range.length > 1 && fieldValue >= range[0] && fieldValue <= range[1];\n    case \"not_between\":\n      return range.length < 2 || fieldValue < range[0] || fieldValue > range[1];\n    case \"include\":\n      return fieldValue?.includes?.(inputValue);\n    case \"not_include\":\n      return typeof fieldValue === \"undefined\" || !fieldValue.includes?.(inputValue);\n  }\n  return false;\n};\nconst getDefaultValueFromFields = (fields) => {\n  const data = {};\n  const defaultValue = {\n    string: void 0,\n    object: {},\n    array: [],\n    boolean: void 0,\n    number: void 0,\n    null: null,\n    any: void 0\n  };\n  fields.forEach((field) => {\n    if (typeof field.defaultValue !== \"undefined\") {\n      if (field.type === \"array\" && !Array.isArray(field.defaultValue)) {\n        data[field.name] = defaultValue.array;\n        return;\n      }\n      if (field.type === \"object\" && !isObject(field.defaultValue)) {\n        if (typeof field.defaultValue === \"string\") {\n          try {\n            data[field.name] = JSON.parse(field.defaultValue);\n          } catch (e) {\n            data[field.name] = defaultValue.object;\n            console.warn(\"defaultValue 解析失败\", field.defaultValue, e);\n          }\n          return;\n        }\n        data[field.name] = defaultValue.object;\n        return;\n      }\n      data[field.name] = cloneDeep(field.defaultValue);\n      return;\n    }\n    if (field.type === \"object\") {\n      data[field.name] = field.fields ? getDefaultValueFromFields(field.fields) : defaultValue.object;\n      return;\n    }\n    if (field.type) {\n      data[field.name] = defaultValue[field.type];\n      return;\n    }\n    data[field.name] = void 0;\n  });\n  return data;\n};\nconst DATA_SOURCE_FIELDS_SELECT_VALUE_PREFIX = \"ds-field::\";\nconst DATA_SOURCE_FIELDS_CHANGE_EVENT_PREFIX = \"ds-field-changed\";\nconst getKeys = Object.keys;\nconst calculatePercentage = (value, percentageStr) => {\n  const percentage = globalThis.parseFloat(percentageStr) / 100;\n  const result = value * percentage;\n  return result;\n};\nconst isPercentage = (value) => /^(\\d+)(\\.\\d+)?%$/.test(`${value}`);\nconst convertToNumber = (value, parentValue = 0) => {\n  if (typeof value === \"number\") {\n    return value;\n  }\n  if (typeof value === \"string\" && isPercentage(value)) {\n    return calculatePercentage(parentValue, value);\n  }\n  return parseFloat(value);\n};\nconst addParamToUrl = (obj, global2 = globalThis, needReload = true) => {\n  const url = new URL(global2.location.href);\n  const { searchParams } = url;\n  for (const [k, v] of Object.entries(obj)) {\n    searchParams.set(k, v);\n  }\n  const newUrl = url.toString();\n  if (needReload) {\n    global2.location.href = newUrl;\n  } else {\n    global2.history.pushState({}, \"\", url);\n  }\n};\nconst dataSourceTemplateRegExp = /\\$\\{([\\s\\S]+?)\\}/g;\nconst isDslNode = (config) => typeof config[IS_DSL_NODE_KEY] === \"undefined\" || config[IS_DSL_NODE_KEY] === true;\nconst traverseNode = (node, cb, parents = [], evalCbAfter = false) => {\n  if (!evalCbAfter) {\n    cb(node, parents);\n  }\n  if (Array.isArray(node.items) && node.items.length) {\n    parents.push(node);\n    node.items.forEach((item) => {\n      traverseNode(item, cb, [...parents], evalCbAfter);\n    });\n  }\n  if (evalCbAfter) {\n    cb(node, parents);\n  }\n};\nconst isValueIncludeDataSource = (value) => {\n  if (typeof value === \"string\" && /\\$\\{([\\s\\S]+?)\\}/.test(value)) {\n    return true;\n  }\n  if (Array.isArray(value) && `${value[0]}`.startsWith(DATA_SOURCE_FIELDS_SELECT_VALUE_PREFIX)) {\n    return true;\n  }\n  if (value?.isBindDataSource && value.dataSourceId) {\n    return true;\n  }\n  if (value?.isBindDataSourceField && value.dataSourceId) {\n    return true;\n  }\n  return false;\n};\n\nexport { DATA_SOURCE_FIELDS_CHANGE_EVENT_PREFIX, DATA_SOURCE_FIELDS_SELECT_VALUE_PREFIX, DSL_NODE_KEY_COPY_PREFIX, IS_DSL_NODE_KEY, PAGE_FRAGMENT_CONTAINER_ID_KEY, addClassName, addParamToUrl, asyncLoadCss, asyncLoadJs, calcValueByFontsize, calculatePercentage, compiledCond, compiledNode, convertToNumber, createDiv, dataSourceTemplateRegExp, delQueStr, emptyFn, filterXSS, getDefaultValueFromFields, getDepKeys, getDepNodeIds, getDocument, getElById, getGlobalThis, getHost, getIdFromEl, getKeys, getKeysArray, getNodeInfo, getNodePath, getNodes, getSearchObj, getUrlParam, getValueByKeyPath, guid, injectStyle, isDslNode, isNumber, isObject, isPage, isPageFragment, isPercentage, isPop, isSameDomain, isValueIncludeDataSource, removeClassName, removeClassNameByClassName, replaceChildNode, setDslDomRelateConfig, setIdToEl, setUrlParam, setValueByKeyPath, sleep, toHump, toLine, traverseNode };\n","/*\n * Tencent is pleased to support the open source community by making TMagicEditor available.\n *\n * Copyright (C) 2025 Tencent.  All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getElById } from '@tmagic/core';\nimport { defineFormConfig } from '@tmagic/form-schema';\n\nexport default defineFormConfig([\n  {\n    name: 'className',\n    type: 'data-source-input',\n    text: 'class',\n  },\n  {\n    name: 'layout',\n    text: '容器布局',\n    type: 'select',\n    defaultValue: 'absolute',\n    options: [\n      { value: 'absolute', text: '绝对定位' },\n      { value: 'relative', text: '流式布局' },\n    ],\n    onChange: (formState: any, v: string, { model, setModel }: any) => {\n      if (!model.style) return v;\n      if (v === 'relative') {\n        setModel('style.height', 'auto');\n      } else {\n        const el = getElById()(formState.stage?.renderer?.contentWindow.document, model.id);\n        if (el) {\n          setModel('style.height', el.getBoundingClientRect().height);\n        }\n      }\n    },\n  },\n]);\n","/*\n * Tencent is pleased to support the open source community by making TMagicEditor available.\n *\n * Copyright (C) 2025 Tencent.  All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { defineFormConfig } from '@tmagic/form-schema';\n\nexport default defineFormConfig([\n  {\n    name: 'className',\n    type: 'data-source-input',\n    text: 'class',\n  },\n  {\n    type: 'data-source-field-select',\n    name: 'src',\n    text: '图片',\n    checkStrictly: false,\n    dataSourceFieldType: ['string'],\n    fieldConfig: {\n      type: 'img-upload',\n    },\n  },\n  {\n    text: '链接',\n    name: 'url',\n    type: 'data-source-input',\n  },\n]);\n","/*\n * Tencent is pleased to support the open source community by making TMagicEditor available.\n *\n * Copyright (C) 2025 Tencent.  All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { DATA_SOURCE_FIELDS_SELECT_VALUE_PREFIX, NODE_CONDS_KEY } from '@tmagic/core';\nimport { defineFormConfig } from '@tmagic/form-schema';\n\nexport default defineFormConfig([\n  {\n    name: 'className',\n    type: 'data-source-input',\n    text: 'class',\n  },\n  {\n    name: 'iteratorData',\n    text: '数据源数据',\n    value: 'value',\n    dataSourceFieldType: ['array'],\n    checkStrictly: true,\n    type: 'data-source-field-select',\n    onChange: (_vm: any, v: string[] = [], { setModel }: any) => {\n      if (Array.isArray(v) && v.length > 1) {\n        const [dsId, ...keys] = v;\n        setModel('dsField', [dsId.replace(DATA_SOURCE_FIELDS_SELECT_VALUE_PREFIX, ''), ...keys]);\n      } else {\n        setModel('dsField', []);\n      }\n    },\n  },\n  {\n    name: 'dsField',\n    type: 'hidden',\n  },\n  {\n    type: 'panel',\n    title: '子项配置',\n    name: 'itemConfig',\n    items: [\n      {\n        type: 'display-conds',\n        name: NODE_CONDS_KEY,\n        titlePrefix: '条件组',\n        defaultValue: [],\n      },\n      {\n        name: 'layout',\n        text: '容器布局',\n        type: 'select',\n        defaultValue: 'absolute',\n        options: [\n          { value: 'absolute', text: '绝对定位' },\n          { value: 'relative', text: '流式布局', disabled: true },\n        ],\n      },\n      {\n        type: 'fieldset',\n        legend: '样式',\n        name: 'style',\n        items: [\n          {\n            name: 'width',\n            text: '宽度',\n          },\n          {\n            name: 'height',\n            text: '高度',\n          },\n          {\n            text: 'overflow',\n            name: 'overflow',\n            type: 'select',\n            options: [\n              { text: 'visible', value: 'visible' },\n              { text: 'hidden', value: 'hidden' },\n              { text: 'clip', value: 'clip' },\n              { text: 'scroll', value: 'scroll' },\n              { text: 'auto', value: 'auto' },\n              { text: 'overlay', value: 'overlay' },\n            ],\n          },\n          {\n            name: 'backgroundImage',\n            text: '背景图',\n          },\n          {\n            name: 'backgroundColor',\n            text: '背景颜色',\n            type: 'colorPicker',\n          },\n          {\n            name: 'backgroundRepeat',\n            text: '背景图重复',\n            type: 'select',\n            defaultValue: 'no-repeat',\n            options: [\n              { text: 'repeat', value: 'repeat' },\n              { text: 'repeat-x', value: 'repeat-x' },\n              { text: 'repeat-y', value: 'repeat-y' },\n              { text: 'no-repeat', value: 'no-repeat' },\n              { text: 'inherit', value: 'inherit' },\n            ],\n          },\n          {\n            name: 'backgroundSize',\n            text: '背景图大小',\n            defaultValue: '100% 100%',\n          },\n        ],\n      },\n    ],\n  },\n]);\n","import { defineFormConfig } from '@tmagic/form-schema';\n\nexport default defineFormConfig([]);\n","/*\n * Tencent is pleased to support the open source community by making TMagicEditor available.\n *\n * Copyright (C) 2025 Tencent.  All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getElById } from '@tmagic/core';\nimport { defineFormConfig } from '@tmagic/form-schema';\n\nexport default defineFormConfig([\n  {\n    text: '页面标识',\n    name: 'name',\n    disabled: true,\n    extra: '在多页面的情况下用来指定要打开的页面',\n  },\n  {\n    text: '页面标题',\n    name: 'title',\n  },\n  {\n    name: 'layout',\n    text: '容器布局',\n    type: 'select',\n    defaultValue: 'absolute',\n    options: [\n      { value: 'absolute', text: '绝对定位' },\n      { value: 'relative', text: '流式布局' },\n    ],\n    onChange: (formState: any, v: string, { model, setModel }: any) => {\n      if (!model.style) return v;\n      if (v === 'relative') {\n        setModel('style.height', 'auto');\n      } else {\n        const el = getElById()(formState.stage?.renderer?.contentWindow.document, model.id);\n        if (el) {\n          setModel('style.height', el.getBoundingClientRect().height);\n        }\n      }\n    },\n  },\n  {\n    name: 'jsFiles',\n    text: 'js',\n    type: 'table',\n    items: [\n      {\n        name: 'url',\n        label: '链接',\n      },\n    ],\n  },\n  {\n    name: 'cssFiles',\n    text: 'css',\n    type: 'table',\n    items: [\n      {\n        name: 'url',\n        label: '链接',\n      },\n    ],\n  },\n  {\n    text: 'css',\n    name: 'css',\n    type: 'vs-code',\n    language: 'css',\n    height: '500px',\n  },\n]);\n","/*\n * Tencent is pleased to support the open source community by making TMagicEditor available.\n *\n * Copyright (C) 2025 Tencent.  All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getElById } from '@tmagic/core';\nimport { defineFormConfig } from '@tmagic/form-schema';\n\nexport default defineFormConfig([\n  {\n    text: '页面片标识',\n    name: 'name',\n    disabled: true,\n  },\n  {\n    text: '页面片标题',\n    name: 'title',\n  },\n  {\n    name: 'layout',\n    text: '容器布局',\n    type: 'select',\n    defaultValue: 'absolute',\n    options: [\n      { value: 'absolute', text: '绝对定位' },\n      { value: 'relative', text: '流式布局' },\n    ],\n    onChange: (formState: any, v: string, { model, setModel }: any) => {\n      if (!model.style) return v;\n      if (v === 'relative') {\n        setModel('style.height', 'auto');\n      } else {\n        const el = getElById()(formState.stage?.renderer?.contentWindow.document, model.id);\n        if (el) {\n          setModel('style.height', el.getBoundingClientRect().height);\n        }\n      }\n    },\n  },\n]);\n","/*\n * Tencent is pleased to support the open source community by making TMagicEditor available.\n *\n * Copyright (C) 2025 Tencent.  All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { defineFormConfig } from '@tmagic/form-schema';\n\nexport default defineFormConfig([\n  {\n    name: 'className',\n    type: 'data-source-input',\n    text: 'class',\n  },\n  {\n    name: 'pageFragmentId',\n    text: '页面片ID',\n    type: 'page-fragment-select',\n  },\n]);\n","/*\n * Tencent is pleased to support the open source community by making TMagicEditor available.\n *\n * Copyright (C) 2025 Tencent.  All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { defineFormConfig } from '@tmagic/form-schema';\n\nexport default defineFormConfig([\n  {\n    name: 'className',\n    type: 'data-source-input',\n    text: 'class',\n  },\n  {\n    text: '链接',\n    name: 'url',\n    type: 'data-source-input',\n  },\n]);\n","/*\n * Tencent is pleased to support the open source community by making TMagicEditor available.\n *\n * Copyright (C) 2025 Tencent.  All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { defineFormConfig } from '@tmagic/form-schema';\n\nexport default defineFormConfig([\n  {\n    name: 'className',\n    type: 'data-source-input',\n    text: 'class',\n  },\n  {\n    name: 'text',\n    text: '文本',\n    type: 'data-source-input',\n  },\n  {\n    name: 'multiple',\n    text: '多行文本',\n    type: 'switch',\n  },\n]);\n","import button from '@tmagic/vue-button/src/formConfig';\nimport container from '@tmagic/vue-container/src/formConfig';\nimport img from '@tmagic/vue-img/src/formConfig';\nimport iteratorContainer from '@tmagic/vue-iterator-container/src/formConfig';\nimport overlay from '@tmagic/vue-overlay/src/formConfig';\nimport page from '@tmagic/vue-page/src/formConfig';\nimport pageFragment from '@tmagic/vue-page-fragment/src/formConfig';\nimport pageFragmentContainer from '@tmagic/vue-page-fragment-container/src/formConfig';\nimport qrcode from '@tmagic/vue-qrcode/src/formConfig';\nimport text from '@tmagic/vue-text/src/formConfig';\n\nconst configs: Record<string, any> = {\n  'button': button,\n  'container': container,\n  'img': img,\n  'iterator-container': iteratorContainer,\n  'overlay': overlay,\n  'page': page,\n  'page-fragment': pageFragment,\n  'page-fragment-container': pageFragmentContainer,\n  'qrcode': qrcode,\n  'text': text,\n};\n\nexport default configs;"],"names":["eventsModule"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14]}