{"version":3,"file":"index.umd.cjs","sources":["../../../../../node_modules/.pnpm/events@3.3.0/node_modules/events/events.js","../../../../../node_modules/.pnpm/deep-state-observer@5.5.13/node_modules/deep-state-observer/index.esm.js","../../../../../node_modules/.pnpm/@tmagic+core@1.6.0_typescript@5.9.2/node_modules/@tmagic/core/dist/tmagic-core.js","../../../../../node_modules/.pnpm/@tmagic+vue-button@0.2.0_@tmagic+core@1.6.0_typescript@5.9.2__@tmagic+vue-runtime-help@_6fdc37761472e4baef276f6f0baa26f5/node_modules/@tmagic/vue-button/src/event.ts","../../../../../node_modules/.pnpm/@tmagic+vue-container@1.2.0_@tmagic+core@1.6.0_typescript@5.9.2__@tmagic+vue-runtime-he_6890d2f5f27c4de0dc53e3198607c099/node_modules/@tmagic/vue-container/src/event.ts","../../../../../node_modules/.pnpm/@tmagic+vue-img@0.2.0_@tmagic+core@1.6.0_typescript@5.9.2__@tmagic+vue-runtime-help@1.2_479ec34a05f68bcb9bfcbf7fa2deb98f/node_modules/@tmagic/vue-img/src/event.ts","../../../../../node_modules/.pnpm/@tmagic+vue-iterator-container@0.2.2_@tmagic+core@1.6.0_typescript@5.9.2__@tmagic+vue-r_55bb8bd30aceb1cc9729fa86d752a135/node_modules/@tmagic/vue-iterator-container/src/event.ts","../../../../../node_modules/.pnpm/@tmagic+vue-overlay@0.2.0_@tmagic+core@1.6.0_typescript@5.9.2__@tmagic+vue-runtime-help_d2323dafed08b37027dcaa710bbfcfd2/node_modules/@tmagic/vue-overlay/src/event.ts","../../../../../node_modules/.pnpm/@tmagic+vue-page@0.2.1_@tmagic+core@1.6.0_typescript@5.9.2__@tmagic+vue-runtime-help@1._0c0ae0503bc0f6064ac4718f1030ebe1/node_modules/@tmagic/vue-page/src/event.ts","../../../../../node_modules/.pnpm/@tmagic+vue-page-fragment@0.2.0_@tmagic+core@1.6.0_typescript@5.9.2__@tmagic+vue-runtim_046bfc4f5e38c118d46f47413eacd6ba/node_modules/@tmagic/vue-page-fragment/src/event.ts","../../../../../node_modules/.pnpm/@tmagic+vue-page-fragment-container@0.2.2_@tmagic+core@1.6.0_typescript@5.9.2__@tmagic+_205d196daa108182891029be0df24f57/node_modules/@tmagic/vue-page-fragment-container/src/event.ts","../../../../../node_modules/.pnpm/@tmagic+vue-qrcode@0.2.0_@tmagic+core@1.6.0_typescript@5.9.2__@tmagic+vue-runtime-help@_c35ed690dcef1473c1065415a62f36a5/node_modules/@tmagic/vue-qrcode/src/event.ts","../../../../../node_modules/.pnpm/@tmagic+vue-text@0.2.1_@tmagic+core@1.6.0_typescript@5.9.2__@tmagic+vue-runtime-help@1._069cafdf3d99c92b353c0cebfc7e783e/node_modules/@tmagic/vue-text/src/event.ts","../../../.tmagic/event-entry.ts"],"sourcesContent":["// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\n\n// forked from https://github.com/joonhocho/superwild\r\nconst segments = [];\r\nfunction Match(pattern, match, wchar = \"*\") {\r\n    if (pattern === wchar) {\r\n        return true;\r\n    }\r\n    segments.length = 0;\r\n    let starCount = 0;\r\n    let minLength = 0;\r\n    let maxLength = 0;\r\n    let segStartIndex = 0;\r\n    for (let i = 0, len = pattern.length; i < len; i += 1) {\r\n        const char = pattern[i];\r\n        if (char === wchar) {\r\n            starCount += 1;\r\n            if (i > segStartIndex) {\r\n                segments.push(pattern.substring(segStartIndex, i));\r\n            }\r\n            segments.push(char);\r\n            segStartIndex = i + 1;\r\n        }\r\n    }\r\n    if (segStartIndex < pattern.length) {\r\n        segments.push(pattern.substring(segStartIndex));\r\n    }\r\n    if (starCount) {\r\n        minLength = pattern.length - starCount;\r\n        maxLength = Infinity;\r\n    }\r\n    else {\r\n        maxLength = minLength = pattern.length;\r\n    }\r\n    if (segments.length === 0) {\r\n        return pattern === match;\r\n    }\r\n    const length = match.length;\r\n    if (length < minLength || length > maxLength) {\r\n        return false;\r\n    }\r\n    let segLeftIndex = 0;\r\n    let segRightIndex = segments.length - 1;\r\n    let rightPos = match.length - 1;\r\n    let rightIsStar = false;\r\n    while (true) {\r\n        const segment = segments[segRightIndex];\r\n        segRightIndex -= 1;\r\n        if (segment === wchar) {\r\n            rightIsStar = true;\r\n        }\r\n        else {\r\n            const lastIndex = rightPos + 1 - segment.length;\r\n            const index = match.lastIndexOf(segment, lastIndex);\r\n            if (index === -1 || index > lastIndex) {\r\n                return false;\r\n            }\r\n            if (rightIsStar) {\r\n                rightPos = index - 1;\r\n                rightIsStar = false;\r\n            }\r\n            else {\r\n                if (index !== lastIndex) {\r\n                    return false;\r\n                }\r\n                rightPos -= segment.length;\r\n            }\r\n        }\r\n        if (segLeftIndex > segRightIndex) {\r\n            break;\r\n        }\r\n    }\r\n    return true;\r\n}\n\nclass WildcardObject {\r\n    constructor(obj, delimiter, wildcard, is_match = undefined) {\r\n        this.obj = obj;\r\n        this.delimiter = delimiter;\r\n        this.wildcard = wildcard;\r\n        this.is_match = is_match;\r\n    }\r\n    shortMatch(first, second) {\r\n        if (first === second)\r\n            return true;\r\n        if (first === this.wildcard)\r\n            return true;\r\n        if (this.is_match)\r\n            return this.is_match(first, second);\r\n        const index = first.indexOf(this.wildcard);\r\n        if (index > -1) {\r\n            const end = first.substr(index + 1);\r\n            if (index === 0 || second.substring(0, index) === first.substring(0, index)) {\r\n                const len = end.length;\r\n                if (len > 0) {\r\n                    return second.substr(-len) === end;\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    match(first, second) {\r\n        if (this.is_match)\r\n            return this.is_match(first, second);\r\n        return (first === second ||\r\n            first === this.wildcard ||\r\n            second === this.wildcard ||\r\n            this.shortMatch(first, second) ||\r\n            Match(first, second, this.wildcard));\r\n    }\r\n    handleArray(wildcard, currentArr, partIndex, path, result = {}) {\r\n        let nextPartIndex = wildcard.indexOf(this.delimiter, partIndex);\r\n        let end = false;\r\n        if (nextPartIndex === -1) {\r\n            end = true;\r\n            nextPartIndex = wildcard.length;\r\n        }\r\n        const currentWildcardPath = wildcard.substring(partIndex, nextPartIndex);\r\n        let index = 0;\r\n        for (const item of currentArr) {\r\n            const key = index.toString();\r\n            const currentPath = path === \"\" ? key : path + this.delimiter + index;\r\n            if (currentWildcardPath === this.wildcard ||\r\n                currentWildcardPath === key ||\r\n                this.shortMatch(currentWildcardPath, key)) {\r\n                end ? (result[currentPath] = item) : this.goFurther(wildcard, item, nextPartIndex + 1, currentPath, result);\r\n            }\r\n            index++;\r\n        }\r\n        return result;\r\n    }\r\n    handleObject(wildcardPath, currentObj, partIndex, path, result = {}) {\r\n        let nextPartIndex = wildcardPath.indexOf(this.delimiter, partIndex);\r\n        let end = false;\r\n        if (nextPartIndex === -1) {\r\n            end = true;\r\n            nextPartIndex = wildcardPath.length;\r\n        }\r\n        const currentWildcardPath = wildcardPath.substring(partIndex, nextPartIndex);\r\n        for (let key in currentObj) {\r\n            key = key.toString();\r\n            const currentPath = path === \"\" ? key : path + this.delimiter + key;\r\n            if (currentWildcardPath === this.wildcard ||\r\n                currentWildcardPath === key ||\r\n                this.shortMatch(currentWildcardPath, key)) {\r\n                if (end) {\r\n                    result[currentPath] = currentObj[key];\r\n                }\r\n                else {\r\n                    this.goFurther(wildcardPath, currentObj[key], nextPartIndex + 1, currentPath, result);\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    goFurther(path, currentObj, partIndex, currentPath, result = {}) {\r\n        if (Array.isArray(currentObj)) {\r\n            return this.handleArray(path, currentObj, partIndex, currentPath, result);\r\n        }\r\n        return this.handleObject(path, currentObj, partIndex, currentPath, result);\r\n    }\r\n    get(path) {\r\n        return this.goFurther(path, this.obj, 0, \"\");\r\n    }\r\n}\n\nclass ObjectPath {\r\n    static get(path, obj, create = false) {\r\n        if (!obj)\r\n            return;\r\n        let currObj = obj;\r\n        for (const currentPath of path) {\r\n            if (currentPath in currObj) {\r\n                currObj = currObj[currentPath];\r\n            }\r\n            else if (create) {\r\n                currObj[currentPath] = Object.create({});\r\n                currObj = currObj[currentPath];\r\n            }\r\n            else {\r\n                return;\r\n            }\r\n        }\r\n        return currObj;\r\n    }\r\n    static set(path, value, obj) {\r\n        if (!obj)\r\n            return;\r\n        if (path.length === 0) {\r\n            for (const key in obj) {\r\n                delete obj[key];\r\n            }\r\n            for (const key in value) {\r\n                obj[key] = value[key];\r\n            }\r\n            return;\r\n        }\r\n        const prePath = path.slice();\r\n        const lastPath = prePath.pop();\r\n        const get = ObjectPath.get(prePath, obj, true);\r\n        if (typeof get === \"object\") {\r\n            get[lastPath] = value;\r\n        }\r\n        return value;\r\n    }\r\n}\n\nlet wasm;\n\nlet WASM_VECTOR_LEN = 0;\n\nlet cachegetUint8Memory0 = null;\nfunction getUint8Memory0() {\n  if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {\n    cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n  }\n  return cachegetUint8Memory0;\n}\n\nlet cachedTextEncoder = new TextEncoder(\"utf-8\");\n\nconst encodeString =\n  typeof cachedTextEncoder.encodeInto === \"function\"\n    ? function (arg, view) {\n        return cachedTextEncoder.encodeInto(arg, view);\n      }\n    : function (arg, view) {\n        const buf = cachedTextEncoder.encode(arg);\n        view.set(buf);\n        return {\n          read: arg.length,\n          written: buf.length,\n        };\n      };\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n  if (realloc === undefined) {\n    const buf = cachedTextEncoder.encode(arg);\n    const ptr = malloc(buf.length);\n    getUint8Memory0()\n      .subarray(ptr, ptr + buf.length)\n      .set(buf);\n    WASM_VECTOR_LEN = buf.length;\n    return ptr;\n  }\n\n  let len = arg.length;\n  let ptr = malloc(len);\n\n  const mem = getUint8Memory0();\n\n  let offset = 0;\n\n  for (; offset < len; offset++) {\n    const code = arg.charCodeAt(offset);\n    if (code > 0x7f) break;\n    mem[ptr + offset] = code;\n  }\n\n  if (offset !== len) {\n    if (offset !== 0) {\n      arg = arg.slice(offset);\n    }\n    ptr = realloc(ptr, len, (len = offset + arg.length * 3));\n    const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n    const ret = encodeString(arg, view);\n\n    offset += ret.written;\n  }\n\n  WASM_VECTOR_LEN = offset;\n  return ptr;\n}\n/**\n * @param {string} pattern\n * @param {string} input\n * @returns {boolean}\n */\nfunction is_match(pattern, input) {\n  var ptr0 = passStringToWasm0(pattern, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n  var len0 = WASM_VECTOR_LEN;\n  var ptr1 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n  var len1 = WASM_VECTOR_LEN;\n  var ret = wasm.is_match(ptr0, len0, ptr1, len1);\n  return ret !== 0;\n}\n\nasync function load(module, imports) {\n  if (typeof Response === \"function\" && module instanceof Response) {\n    if (typeof WebAssembly.instantiateStreaming === \"function\") {\n      try {\n        return await WebAssembly.instantiateStreaming(module, imports);\n      } catch (e) {\n        if (module.headers.get(\"Content-Type\") != \"application/wasm\") {\n          console.warn(\n            \"`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\",\n            e\n          );\n        } else {\n          throw e;\n        }\n      }\n    }\n\n    const bytes = await module.arrayBuffer();\n    return await WebAssembly.instantiate(bytes, imports);\n  } else {\n    const instance = await WebAssembly.instantiate(module, imports);\n\n    if (instance instanceof WebAssembly.Instance) {\n      return { instance, module };\n    } else {\n      return instance;\n    }\n  }\n}\n\nasync function init(input) {\n  const imports = {};\n  if (\n    typeof input === \"string\" ||\n    (typeof Request === \"function\" && input instanceof Request) ||\n    (typeof URL === \"function\" && input instanceof URL)\n  ) {\n    input = fetch(input);\n  }\n  const { instance, module } = await load(await input, imports);\n  wasm = instance.exports;\n  init.__wbindgen_wasm_module = module;\n  return wasm;\n}\n\nconst defaultUpdateOptions = {\r\n    only: [],\r\n    source: \"\",\r\n    debug: false,\r\n    data: undefined,\r\n    queue: false,\r\n    force: false,\r\n};\r\nfunction log(message, info) {\r\n    console.debug(message, info);\r\n}\r\nfunction getDefaultOptions() {\r\n    return {\r\n        delimiter: `.`,\r\n        debug: false,\r\n        extraDebug: false,\r\n        useMute: true,\r\n        notRecursive: `;`,\r\n        param: `:`,\r\n        wildcard: `*`,\r\n        experimentalMatch: false,\r\n        queue: false,\r\n        defaultBulkValue: true,\r\n        useCache: false,\r\n        useSplitCache: false,\r\n        useIndicesCache: false,\r\n        maxSimultaneousJobs: 1000,\r\n        maxQueueRuns: 1000,\r\n        log,\r\n        Promise,\r\n    };\r\n}\r\n/**\r\n * Is object - helper function to determine if specified variable is an object\r\n *\r\n * @param {any} item\r\n * @returns {boolean}\r\n */\r\nfunction isObject(item) {\r\n    if (item && item.constructor) {\r\n        return item.constructor.name === \"Object\";\r\n    }\r\n    return typeof item === \"object\" && item !== null;\r\n}\r\nclass DeepState {\r\n    constructor(data = {}, options = {}) {\r\n        this.jobsRunning = 0;\r\n        this.updateQueue = [];\r\n        this.subscribeQueue = [];\r\n        this.listenersIgnoreCache = new WeakMap();\r\n        this.is_match = null;\r\n        this.destroyed = false;\r\n        this.queueRuns = 0;\r\n        this.groupId = 0;\r\n        this.namedGroups = [];\r\n        this.numberGroups = [];\r\n        this.traceId = 0;\r\n        this.traceMap = new Map();\r\n        this.tracing = [];\r\n        this.savedTrace = [];\r\n        this.collection = null;\r\n        this.collections = 0;\r\n        this.cache = new Map();\r\n        this.splitCache = new Map();\r\n        this.indices = new Map();\r\n        this.indicesCount = new Map();\r\n        this.lastExecs = new WeakMap();\r\n        this.listeners = new Map();\r\n        this.waitingListeners = new Map();\r\n        this.options = Object.assign(Object.assign({}, getDefaultOptions()), options);\r\n        this.data = data;\r\n        this.id = 0;\r\n        if (!this.options.useCache) {\r\n            this.pathGet = ObjectPath.get;\r\n            this.pathSet = ObjectPath.set;\r\n        }\r\n        else {\r\n            this.pathGet = this.cacheGet;\r\n            this.pathSet = this.cacheSet;\r\n        }\r\n        if (options.Promise) {\r\n            this.resolved = options.Promise.resolve();\r\n        }\r\n        else {\r\n            this.resolved = Promise.resolve();\r\n        }\r\n        this.muted = new Set();\r\n        this.mutedListeners = new Set();\r\n        this.scan = new WildcardObject(this.data, this.options.delimiter, this.options.wildcard);\r\n        this.destroyed = false;\r\n    }\r\n    getDefaultListenerOptions() {\r\n        return {\r\n            bulk: false,\r\n            bulkValue: this.options.defaultBulkValue,\r\n            debug: false,\r\n            source: \"\",\r\n            data: undefined,\r\n            queue: false,\r\n            group: false,\r\n        };\r\n    }\r\n    cacheGet(pathChunks, data = this.data, create = false) {\r\n        const path = pathChunks.join(this.options.delimiter);\r\n        const weakRefValue = this.cache.get(path);\r\n        if (weakRefValue) {\r\n            const value = weakRefValue.deref();\r\n            if (value) {\r\n                return value;\r\n            }\r\n        }\r\n        const value = ObjectPath.get(pathChunks, data, create);\r\n        if (isObject(value) || Array.isArray(value)) {\r\n            // @ts-ignore-next-line\r\n            this.cache.set(path, new WeakRef(value));\r\n        }\r\n        return value;\r\n    }\r\n    cacheSet(pathChunks, value, data = this.data) {\r\n        const path = pathChunks.join(this.options.delimiter);\r\n        if (isObject(value) || Array.isArray(value)) {\r\n            this.cache.set(path, \r\n            //@ts-ignore-next-line\r\n            new WeakRef(value));\r\n        }\r\n        else {\r\n            this.cache.delete(path);\r\n        }\r\n        return ObjectPath.set(pathChunks, value, data);\r\n    }\r\n    /**\r\n     * Silently update data\r\n     * @param path string\r\n     * @param value any\r\n     * @returns\r\n     */\r\n    silentSet(path, value) {\r\n        return this.pathSet(this.split(path), value, this.data);\r\n    }\r\n    loadWasmMatcher(pathToWasmFile) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            yield init(pathToWasmFile);\r\n            this.is_match = is_match;\r\n            this.scan = new WildcardObject(this.data, this.options.delimiter, this.options.wildcard, this.is_match);\r\n        });\r\n    }\r\n    same(newValue, oldValue) {\r\n        return (([\"number\", \"string\", \"undefined\", \"boolean\"].includes(typeof newValue) || newValue === null) &&\r\n            oldValue === newValue);\r\n    }\r\n    getListeners() {\r\n        return this.listeners;\r\n    }\r\n    destroy() {\r\n        this.destroyed = true;\r\n        this.data = undefined;\r\n        this.listeners = new Map();\r\n        this.waitingListeners = new Map();\r\n        this.updateQueue = [];\r\n        this.jobsRunning = 0;\r\n    }\r\n    match(first, second, nested = true) {\r\n        if (this.is_match)\r\n            return this.is_match(first, second);\r\n        if (first === second)\r\n            return true;\r\n        if (first === this.options.wildcard || second === this.options.wildcard)\r\n            return true;\r\n        if (!nested &&\r\n            this.getIndicesCount(this.options.delimiter, first) < this.getIndicesCount(this.options.delimiter, second)) {\r\n            // first < second because first is a listener path and may be longer but not shorter\r\n            return false;\r\n        }\r\n        return this.scan.match(first, second);\r\n    }\r\n    getIndicesOf(searchStr, str) {\r\n        if (this.options.useIndicesCache && this.indices.has(str))\r\n            return this.indices.get(str);\r\n        const searchStrLen = searchStr.length;\r\n        if (searchStrLen == 0) {\r\n            return [];\r\n        }\r\n        let startIndex = 0, index, indices = [];\r\n        while ((index = str.indexOf(searchStr, startIndex)) > -1) {\r\n            indices.push(index);\r\n            startIndex = index + searchStrLen;\r\n        }\r\n        if (this.options.useIndicesCache)\r\n            this.indices.set(str, indices);\r\n        return indices;\r\n    }\r\n    getIndicesCount(searchStr, str) {\r\n        if (this.options.useIndicesCache && this.indicesCount.has(str))\r\n            return this.indicesCount.get(str);\r\n        const searchStrLen = searchStr.length;\r\n        if (searchStrLen == 0) {\r\n            return 0;\r\n        }\r\n        let startIndex = 0, index, indices = 0;\r\n        while ((index = str.indexOf(searchStr, startIndex)) > -1) {\r\n            indices++;\r\n            startIndex = index + searchStrLen;\r\n        }\r\n        if (this.options.useIndicesCache)\r\n            this.indicesCount.set(str, indices);\r\n        return indices;\r\n    }\r\n    cutPath(longer, shorter) {\r\n        if (shorter === \"\")\r\n            return \"\";\r\n        longer = this.cleanNotRecursivePath(longer);\r\n        shorter = this.cleanNotRecursivePath(shorter);\r\n        if (longer === shorter)\r\n            return longer;\r\n        const shorterPartsLen = this.getIndicesCount(this.options.delimiter, shorter);\r\n        const longerParts = this.getIndicesOf(this.options.delimiter, longer);\r\n        return longer.substring(0, longerParts[shorterPartsLen]);\r\n    }\r\n    trimPath(path) {\r\n        path = this.cleanNotRecursivePath(path);\r\n        if (path.charAt(0) === this.options.delimiter) {\r\n            return path.substr(1);\r\n        }\r\n        return path;\r\n    }\r\n    split(path) {\r\n        if (path === \"\")\r\n            return [];\r\n        if (!this.options.useSplitCache) {\r\n            return path.split(this.options.delimiter);\r\n        }\r\n        const fromCache = this.splitCache.get(path);\r\n        if (fromCache) {\r\n            return fromCache.slice();\r\n        }\r\n        const value = path.split(this.options.delimiter);\r\n        this.splitCache.set(path, value.slice());\r\n        return value;\r\n    }\r\n    isWildcard(path) {\r\n        return path.includes(this.options.wildcard) || this.hasParams(path);\r\n    }\r\n    isNotRecursive(path) {\r\n        return path.endsWith(this.options.notRecursive);\r\n    }\r\n    cleanNotRecursivePath(path) {\r\n        return this.isNotRecursive(path) ? path.substring(0, path.length - 1) : path;\r\n    }\r\n    hasParams(path) {\r\n        return path.includes(this.options.param);\r\n    }\r\n    getParamsInfo(path) {\r\n        let paramsInfo = { replaced: \"\", original: path, params: {} };\r\n        let partIndex = 0;\r\n        let fullReplaced = [];\r\n        for (const part of this.split(path)) {\r\n            paramsInfo.params[partIndex] = {\r\n                original: part,\r\n                replaced: \"\",\r\n                name: \"\",\r\n            };\r\n            const reg = new RegExp(`\\\\${this.options.param}([^\\\\${this.options.delimiter}\\\\${this.options.param}]+)`, \"g\");\r\n            let param = reg.exec(part);\r\n            if (param) {\r\n                paramsInfo.params[partIndex].name = param[1];\r\n            }\r\n            else {\r\n                delete paramsInfo.params[partIndex];\r\n                fullReplaced.push(part);\r\n                partIndex++;\r\n                continue;\r\n            }\r\n            reg.lastIndex = 0;\r\n            paramsInfo.params[partIndex].replaced = part.replace(reg, this.options.wildcard);\r\n            fullReplaced.push(paramsInfo.params[partIndex].replaced);\r\n            partIndex++;\r\n        }\r\n        paramsInfo.replaced = fullReplaced.join(this.options.delimiter);\r\n        return paramsInfo;\r\n    }\r\n    getParams(paramsInfo, path) {\r\n        if (!paramsInfo) {\r\n            return undefined;\r\n        }\r\n        const split = this.split(path);\r\n        const result = {};\r\n        for (const partIndex in paramsInfo.params) {\r\n            const param = paramsInfo.params[partIndex];\r\n            result[param.name] = split[partIndex];\r\n        }\r\n        return result;\r\n    }\r\n    waitForAll(userPaths, fn) {\r\n        const paths = {};\r\n        for (let path of userPaths) {\r\n            paths[path] = { dirty: false };\r\n            if (this.hasParams(path)) {\r\n                paths[path].paramsInfo = this.getParamsInfo(path);\r\n            }\r\n            paths[path].isWildcard = this.isWildcard(path);\r\n            paths[path].isRecursive = !this.isNotRecursive(path);\r\n        }\r\n        this.waitingListeners.set(userPaths, { fn, paths });\r\n        fn(paths);\r\n        return function unsubscribe() {\r\n            this.waitingListeners.delete(userPaths);\r\n        };\r\n    }\r\n    executeWaitingListeners(updatePath) {\r\n        if (this.destroyed)\r\n            return;\r\n        for (const waitingListener of this.waitingListeners.values()) {\r\n            const { fn, paths } = waitingListener;\r\n            let dirty = 0;\r\n            let all = 0;\r\n            for (let path in paths) {\r\n                const pathInfo = paths[path];\r\n                let match = false;\r\n                if (pathInfo.isRecursive)\r\n                    updatePath = this.cutPath(updatePath, path);\r\n                if (pathInfo.isWildcard && this.match(path, updatePath))\r\n                    match = true;\r\n                if (updatePath === path)\r\n                    match = true;\r\n                if (match) {\r\n                    pathInfo.dirty = true;\r\n                }\r\n                if (pathInfo.dirty) {\r\n                    dirty++;\r\n                }\r\n                all++;\r\n            }\r\n            if (dirty === all) {\r\n                fn(paths);\r\n            }\r\n        }\r\n    }\r\n    subscribeAll(userPaths, fn, options = this.getDefaultListenerOptions()) {\r\n        if (this.destroyed)\r\n            return () => { };\r\n        let unsubscribers = [];\r\n        let index = 0;\r\n        let groupId = null;\r\n        if (typeof options.group === \"boolean\" && options.group) {\r\n            this.groupId++;\r\n            groupId = this.groupId;\r\n            options.bulk = true;\r\n        }\r\n        else if (typeof options.group === \"string\") {\r\n            options.bulk = true;\r\n            groupId = options.group;\r\n        }\r\n        for (const userPath of userPaths) {\r\n            unsubscribers.push(this.subscribe(userPath, fn, options, {\r\n                all: userPaths,\r\n                index,\r\n                groupId,\r\n            }));\r\n            index++;\r\n        }\r\n        return function unsubscribe() {\r\n            for (const unsubscribe of unsubscribers) {\r\n                unsubscribe();\r\n            }\r\n        };\r\n    }\r\n    getCleanListenersCollection(values = {}) {\r\n        return Object.assign({ listeners: new Map(), isRecursive: false, isWildcard: false, hasParams: false, match: undefined, paramsInfo: undefined, path: undefined, originalPath: undefined, count: 0 }, values);\r\n    }\r\n    getCleanListener(fn, options = this.getDefaultListenerOptions()) {\r\n        return {\r\n            fn,\r\n            options: Object.assign(Object.assign({}, this.getDefaultListenerOptions()), options),\r\n            groupId: null,\r\n        };\r\n    }\r\n    getListenerCollectionMatch(listenerPath, isRecursive, isWildcard) {\r\n        listenerPath = this.cleanNotRecursivePath(listenerPath);\r\n        const self = this;\r\n        return function listenerCollectionMatch(path, debug = false) {\r\n            let scopedListenerPath = listenerPath;\r\n            if (isRecursive) {\r\n                path = self.cutPath(path, listenerPath);\r\n            }\r\n            else {\r\n                scopedListenerPath = self.cutPath(self.cleanNotRecursivePath(listenerPath), path);\r\n            }\r\n            if (debug) {\r\n                console.log(\"[getListenerCollectionMatch]\", {\r\n                    listenerPath,\r\n                    scopedListenerPath,\r\n                    path,\r\n                    isRecursive,\r\n                    isWildcard,\r\n                });\r\n            }\r\n            if (isWildcard && self.match(scopedListenerPath, path, isRecursive))\r\n                return true;\r\n            return scopedListenerPath === path;\r\n        };\r\n    }\r\n    getListenersCollection(listenerPath, listener) {\r\n        if (this.listeners.has(listenerPath)) {\r\n            let listenersCollection = this.listeners.get(listenerPath);\r\n            listenersCollection.listeners.set(++this.id, listener);\r\n            listener.id = this.id;\r\n            return listenersCollection;\r\n        }\r\n        const hasParams = this.hasParams(listenerPath);\r\n        let paramsInfo;\r\n        if (hasParams) {\r\n            paramsInfo = this.getParamsInfo(listenerPath);\r\n        }\r\n        let collCfg = {\r\n            isRecursive: !this.isNotRecursive(listenerPath),\r\n            isWildcard: this.isWildcard(listenerPath),\r\n            hasParams,\r\n            paramsInfo,\r\n            originalPath: listenerPath,\r\n            path: hasParams ? paramsInfo.replaced : listenerPath,\r\n        };\r\n        if (!collCfg.isRecursive) {\r\n            collCfg.path = this.cleanNotRecursivePath(collCfg.path);\r\n        }\r\n        let listenersCollection = this.getCleanListenersCollection(Object.assign(Object.assign({}, collCfg), { match: this.getListenerCollectionMatch(collCfg.path, collCfg.isRecursive, collCfg.isWildcard) }));\r\n        this.id++;\r\n        listenersCollection.listeners.set(this.id, listener);\r\n        listener.id = this.id;\r\n        this.listeners.set(collCfg.originalPath, listenersCollection);\r\n        return listenersCollection;\r\n    }\r\n    subscribe(listenerPath, fn, options = this.getDefaultListenerOptions(), subscribeAllOptions = {\r\n        all: [listenerPath],\r\n        index: 0,\r\n        groupId: null,\r\n    }) {\r\n        if (this.destroyed)\r\n            return () => { };\r\n        this.jobsRunning++;\r\n        const type = \"subscribe\";\r\n        let listener = this.getCleanListener(fn, options);\r\n        if (options.group) {\r\n            options.bulk = true;\r\n            if (typeof options.group === \"string\") {\r\n                listener.groupId = options.group;\r\n            }\r\n            else if (subscribeAllOptions.groupId) {\r\n                listener.groupId = subscribeAllOptions.groupId;\r\n            }\r\n        }\r\n        this.listenersIgnoreCache.set(listener, { truthy: [], falsy: [] });\r\n        const listenersCollection = this.getListenersCollection(listenerPath, listener);\r\n        if (options.debug) {\r\n            console.log(\"[subscribe]\", { listenerPath, options });\r\n        }\r\n        listenersCollection.count++;\r\n        let shouldFire = true;\r\n        if (listener.groupId) {\r\n            if (typeof listener.groupId === \"string\") {\r\n                if (this.namedGroups.includes(listener.groupId)) {\r\n                    shouldFire = false;\r\n                }\r\n                else {\r\n                    this.namedGroups.push(listener.groupId);\r\n                }\r\n            }\r\n            else if (typeof listener.groupId === \"number\") {\r\n                if (this.numberGroups.includes(listener.groupId)) {\r\n                    shouldFire = false;\r\n                }\r\n                else {\r\n                    this.numberGroups.push(listener.groupId);\r\n                }\r\n            }\r\n        }\r\n        if (shouldFire) {\r\n            const cleanPath = this.cleanNotRecursivePath(listenersCollection.path);\r\n            const cleanPathChunks = this.split(cleanPath);\r\n            if (!listenersCollection.isWildcard) {\r\n                if (!this.isMuted(cleanPath) && !this.isMuted(fn)) {\r\n                    fn(this.pathGet(cleanPathChunks, this.data), {\r\n                        type,\r\n                        listener,\r\n                        listenersCollection,\r\n                        path: {\r\n                            listener: listenerPath,\r\n                            update: undefined,\r\n                            resolved: this.cleanNotRecursivePath(listenerPath),\r\n                        },\r\n                        params: this.getParams(listenersCollection.paramsInfo, cleanPath),\r\n                        options,\r\n                    });\r\n                }\r\n            }\r\n            else {\r\n                const paths = this.scan.get(cleanPath);\r\n                if (options.bulk) {\r\n                    const bulkValue = [];\r\n                    for (const path in paths) {\r\n                        if (this.isMuted(path))\r\n                            continue;\r\n                        bulkValue.push({\r\n                            path,\r\n                            params: this.getParams(listenersCollection.paramsInfo, path),\r\n                            value: paths[path],\r\n                        });\r\n                    }\r\n                    if (!this.isMuted(fn)) {\r\n                        fn(bulkValue, {\r\n                            type,\r\n                            listener,\r\n                            listenersCollection,\r\n                            path: {\r\n                                listener: listenerPath,\r\n                                update: undefined,\r\n                                resolved: undefined,\r\n                            },\r\n                            options,\r\n                            params: undefined,\r\n                        });\r\n                    }\r\n                }\r\n                else {\r\n                    for (const path in paths) {\r\n                        if (!this.isMuted(path) && !this.isMuted(fn)) {\r\n                            fn(paths[path], {\r\n                                type,\r\n                                listener,\r\n                                listenersCollection,\r\n                                path: {\r\n                                    listener: listenerPath,\r\n                                    update: undefined,\r\n                                    resolved: this.cleanNotRecursivePath(path),\r\n                                },\r\n                                params: this.getParams(listenersCollection.paramsInfo, path),\r\n                                options,\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this.debugSubscribe(listener, listenersCollection, listenerPath);\r\n        this.jobsRunning--;\r\n        return this.unsubscribe(listenerPath, this.id);\r\n    }\r\n    unsubscribe(path, id) {\r\n        const listeners = this.listeners;\r\n        const listenersCollection = listeners.get(path);\r\n        return function unsub() {\r\n            listenersCollection.listeners.delete(id);\r\n            listenersCollection.count--;\r\n            if (listenersCollection.count === 0) {\r\n                listeners.delete(path);\r\n            }\r\n        };\r\n    }\r\n    runQueuedListeners() {\r\n        if (this.destroyed)\r\n            return;\r\n        if (this.subscribeQueue.length === 0)\r\n            return;\r\n        if (this.jobsRunning === 0) {\r\n            this.queueRuns = 0;\r\n            const queue = [...this.subscribeQueue];\r\n            for (let i = 0, len = queue.length; i < len; i++) {\r\n                queue[i]();\r\n            }\r\n            this.subscribeQueue.length = 0;\r\n        }\r\n        else {\r\n            this.queueRuns++;\r\n            if (this.queueRuns >= this.options.maxQueueRuns) {\r\n                this.queueRuns = 0;\r\n                throw new Error(\"Maximal number of queue runs exhausted.\");\r\n            }\r\n            else {\r\n                Promise.resolve()\r\n                    .then(() => this.runQueuedListeners())\r\n                    .catch((e) => {\r\n                    throw e;\r\n                });\r\n            }\r\n        }\r\n    }\r\n    getQueueNotifyListeners(groupedListeners, queue = []) {\r\n        for (const path in groupedListeners) {\r\n            if (this.isMuted(path))\r\n                continue;\r\n            let { single, bulk } = groupedListeners[path];\r\n            for (const singleListener of single) {\r\n                let alreadyInQueue = false;\r\n                let resolvedIdPath = singleListener.listener.id + \":\" + singleListener.eventInfo.path.resolved;\r\n                if (!singleListener.eventInfo.path.resolved) {\r\n                    resolvedIdPath = singleListener.listener.id + \":\" + singleListener.eventInfo.path.listener;\r\n                }\r\n                for (const excludedListener of queue) {\r\n                    if (resolvedIdPath === excludedListener.resolvedIdPath) {\r\n                        alreadyInQueue = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (alreadyInQueue) {\r\n                    continue;\r\n                }\r\n                const time = this.debugTime(singleListener);\r\n                if (!this.isMuted(singleListener.listener.fn)) {\r\n                    if (singleListener.listener.options.queue && this.jobsRunning) {\r\n                        this.subscribeQueue.push(() => {\r\n                            singleListener.listener.fn(singleListener.value ? singleListener.value() : undefined, singleListener.eventInfo);\r\n                        });\r\n                    }\r\n                    else {\r\n                        let resolvedIdPath = singleListener.listener.id + \":\" + singleListener.eventInfo.path.resolved;\r\n                        if (!singleListener.eventInfo.path.resolved) {\r\n                            resolvedIdPath = singleListener.listener.id + \":\" + singleListener.eventInfo.path.listener;\r\n                        }\r\n                        queue.push({\r\n                            id: singleListener.listener.id,\r\n                            resolvedPath: singleListener.eventInfo.path.resolved,\r\n                            resolvedIdPath,\r\n                            originalFn: singleListener.listener.fn,\r\n                            fn: () => {\r\n                                singleListener.listener.fn(singleListener.value ? singleListener.value() : undefined, singleListener.eventInfo);\r\n                            },\r\n                            options: singleListener.listener.options,\r\n                            groupId: singleListener.listener.groupId,\r\n                        });\r\n                    }\r\n                }\r\n                this.debugListener(time, singleListener);\r\n            }\r\n            for (const bulkListener of bulk) {\r\n                let alreadyInQueue = false;\r\n                for (const excludedListener of queue) {\r\n                    if (excludedListener.id === bulkListener.listener.id) {\r\n                        alreadyInQueue = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (alreadyInQueue)\r\n                    continue;\r\n                const time = this.debugTime(bulkListener);\r\n                const bulkValue = [];\r\n                for (const bulk of bulkListener.value) {\r\n                    bulkValue.push(Object.assign(Object.assign({}, bulk), { value: bulk.value ? bulk.value() : undefined }));\r\n                }\r\n                if (!this.isMuted(bulkListener.listener.fn)) {\r\n                    if (bulkListener.listener.options.queue && this.jobsRunning) {\r\n                        this.subscribeQueue.push(() => {\r\n                            if (!this.jobsRunning) {\r\n                                bulkListener.listener.fn(bulkValue, bulkListener.eventInfo);\r\n                                return true;\r\n                            }\r\n                            return false;\r\n                        });\r\n                    }\r\n                    else {\r\n                        let resolvedIdPath = bulkListener.listener.id + \":\" + bulkListener.eventInfo.path.resolved;\r\n                        if (!bulkListener.eventInfo.path.resolved) {\r\n                            resolvedIdPath = bulkListener.listener.id + \":\" + bulkListener.eventInfo.path.listener;\r\n                        }\r\n                        queue.push({\r\n                            id: bulkListener.listener.id,\r\n                            resolvedPath: bulkListener.eventInfo.path.resolved,\r\n                            resolvedIdPath,\r\n                            originalFn: bulkListener.listener.fn,\r\n                            fn: () => {\r\n                                bulkListener.listener.fn(bulkValue, bulkListener.eventInfo);\r\n                            },\r\n                            options: bulkListener.listener.options,\r\n                            groupId: bulkListener.listener.groupId,\r\n                        });\r\n                    }\r\n                }\r\n                this.debugListener(time, bulkListener);\r\n            }\r\n        }\r\n        Promise.resolve().then(() => this.runQueuedListeners());\r\n        return queue;\r\n    }\r\n    shouldIgnore(listener, updatePath) {\r\n        if (!listener.options.ignore)\r\n            return false;\r\n        for (const ignorePath of listener.options.ignore) {\r\n            if (updatePath.startsWith(ignorePath)) {\r\n                return true;\r\n            }\r\n            if (this.is_match && this.is_match(ignorePath, updatePath)) {\r\n                return true;\r\n            }\r\n            else {\r\n                const cuttedUpdatePath = this.cutPath(updatePath, ignorePath);\r\n                if (this.match(ignorePath, cuttedUpdatePath)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    getSubscribedListeners(updatePath, newValue, options, type = \"update\", originalPath = null) {\r\n        options = Object.assign(Object.assign({}, defaultUpdateOptions), options);\r\n        const listeners = {};\r\n        for (let [listenerPath, listenersCollection] of this.listeners) {\r\n            if (listenersCollection.match(updatePath)) {\r\n                listeners[listenerPath] = { single: [], bulk: [], bulkData: [] };\r\n                const params = listenersCollection.paramsInfo\r\n                    ? this.getParams(listenersCollection.paramsInfo, updatePath)\r\n                    : undefined;\r\n                const cutPath = this.cutPath(updatePath, listenerPath);\r\n                const traverse = listenersCollection.isRecursive || listenersCollection.isWildcard;\r\n                const value = traverse ? () => this.get(cutPath) : () => newValue;\r\n                const bulkValue = [{ value, path: updatePath, params }];\r\n                for (const listener of listenersCollection.listeners.values()) {\r\n                    if (this.shouldIgnore(listener, updatePath)) {\r\n                        if (listener.options.debug) {\r\n                            console.log(`[getSubscribedListeners] Listener was not fired because it was ignored.`, {\r\n                                listener,\r\n                                listenersCollection,\r\n                            });\r\n                        }\r\n                        continue;\r\n                    }\r\n                    if (listener.options.bulk) {\r\n                        listeners[listenerPath].bulk.push({\r\n                            listener,\r\n                            listenersCollection,\r\n                            eventInfo: {\r\n                                type,\r\n                                listener,\r\n                                path: {\r\n                                    listener: listenerPath,\r\n                                    update: originalPath ? originalPath : updatePath,\r\n                                    resolved: undefined,\r\n                                },\r\n                                params,\r\n                                options,\r\n                            },\r\n                            value: bulkValue,\r\n                        });\r\n                    }\r\n                    else {\r\n                        listeners[listenerPath].single.push({\r\n                            listener,\r\n                            listenersCollection,\r\n                            eventInfo: {\r\n                                type,\r\n                                listener,\r\n                                path: {\r\n                                    listener: listenerPath,\r\n                                    update: originalPath ? originalPath : updatePath,\r\n                                    resolved: this.cleanNotRecursivePath(updatePath),\r\n                                },\r\n                                params,\r\n                                options,\r\n                            },\r\n                            value,\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n            else if (this.options.extraDebug) {\r\n                // debug\r\n                let showMatch = false;\r\n                for (const listener of listenersCollection.listeners.values()) {\r\n                    if (listener.options.debug) {\r\n                        showMatch = true;\r\n                        console.log(`[getSubscribedListeners] Listener was not fired because there was no match.`, {\r\n                            listener,\r\n                            listenersCollection,\r\n                            updatePath,\r\n                        });\r\n                    }\r\n                }\r\n                if (showMatch) {\r\n                    listenersCollection.match(updatePath, true);\r\n                }\r\n            }\r\n        }\r\n        return listeners;\r\n    }\r\n    notifySubscribedListeners(updatePath, newValue, options, type = \"update\", originalPath = null) {\r\n        return this.getQueueNotifyListeners(this.getSubscribedListeners(updatePath, newValue, options, type, originalPath));\r\n    }\r\n    useBulkValue(listenersCollection) {\r\n        for (const [listenerId, listener] of listenersCollection.listeners) {\r\n            if (listener.options.bulk && listener.options.bulkValue)\r\n                return true;\r\n            if (!listener.options.bulk)\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n    getNestedListeners(updatePath, newValue, options, type = \"update\", originalPath = null) {\r\n        const listeners = {};\r\n        const restBelowValues = {};\r\n        for (let [listenerPath, listenersCollection] of this.listeners) {\r\n            if (!listenersCollection.isRecursive)\r\n                continue;\r\n            // listenerPath may be longer and is shortened - because we want to get listeners underneath change\r\n            const currentAbovePathCut = this.cutPath(listenerPath, updatePath);\r\n            if (this.match(currentAbovePathCut, updatePath)) {\r\n                listeners[listenerPath] = { single: [], bulk: [] };\r\n                // listener is listening below updated node\r\n                const restBelowPathCut = this.trimPath(listenerPath.substr(currentAbovePathCut.length));\r\n                const useBulkValue = this.useBulkValue(listenersCollection);\r\n                let wildcardNewValues;\r\n                if (useBulkValue) {\r\n                    wildcardNewValues = restBelowValues[restBelowPathCut]\r\n                        ? restBelowValues[restBelowPathCut] // if those values are already calculated use it\r\n                        : new WildcardObject(newValue, this.options.delimiter, this.options.wildcard).get(restBelowPathCut);\r\n                    restBelowValues[restBelowPathCut] = wildcardNewValues;\r\n                }\r\n                const params = listenersCollection.paramsInfo\r\n                    ? this.getParams(listenersCollection.paramsInfo, updatePath)\r\n                    : undefined;\r\n                const bulk = [];\r\n                const bulkListeners = {};\r\n                for (const [listenerId, listener] of listenersCollection.listeners) {\r\n                    if (useBulkValue) {\r\n                        for (const currentRestPath in wildcardNewValues) {\r\n                            const value = () => wildcardNewValues[currentRestPath];\r\n                            const fullPath = [updatePath, currentRestPath].join(this.options.delimiter);\r\n                            const eventInfo = {\r\n                                type,\r\n                                listener,\r\n                                listenersCollection,\r\n                                path: {\r\n                                    listener: listenerPath,\r\n                                    update: originalPath ? originalPath : updatePath,\r\n                                    resolved: this.cleanNotRecursivePath(fullPath),\r\n                                },\r\n                                params,\r\n                                options,\r\n                            };\r\n                            if (this.shouldIgnore(listener, updatePath))\r\n                                continue;\r\n                            if (listener.options.bulk) {\r\n                                bulk.push({ value, path: fullPath, params });\r\n                                bulkListeners[listenerId] = listener;\r\n                            }\r\n                            else {\r\n                                listeners[listenerPath].single.push({\r\n                                    listener,\r\n                                    listenersCollection,\r\n                                    eventInfo,\r\n                                    value,\r\n                                });\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        const eventInfo = {\r\n                            type,\r\n                            listener,\r\n                            listenersCollection,\r\n                            path: {\r\n                                listener: listenerPath,\r\n                                update: originalPath ? originalPath : updatePath,\r\n                                resolved: undefined,\r\n                            },\r\n                            params,\r\n                            options,\r\n                        };\r\n                        if (this.shouldIgnore(listener, updatePath))\r\n                            continue;\r\n                        if (listener.options.bulk) {\r\n                            bulk.push({ value: undefined, path: undefined, params });\r\n                            bulkListeners[listenerId] = listener;\r\n                        }\r\n                        else {\r\n                            listeners[listenerPath].single.push({\r\n                                listener,\r\n                                listenersCollection,\r\n                                eventInfo,\r\n                                value: undefined,\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n                for (const listenerId in bulkListeners) {\r\n                    const listener = bulkListeners[listenerId];\r\n                    const eventInfo = {\r\n                        type,\r\n                        listener,\r\n                        listenersCollection,\r\n                        path: {\r\n                            listener: listenerPath,\r\n                            update: updatePath,\r\n                            resolved: undefined,\r\n                        },\r\n                        options,\r\n                        params,\r\n                    };\r\n                    listeners[listenerPath].bulk.push({\r\n                        listener,\r\n                        listenersCollection,\r\n                        eventInfo,\r\n                        value: bulk,\r\n                    });\r\n                }\r\n            }\r\n            else if (this.options.extraDebug) {\r\n                // debug\r\n                for (const listener of listenersCollection.listeners.values()) {\r\n                    if (listener.options.debug) {\r\n                        console.log(\"[getNestedListeners] Listener was not fired because there was no match.\", {\r\n                            listener,\r\n                            listenersCollection,\r\n                            currentCutPath: currentAbovePathCut,\r\n                            updatePath,\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return listeners;\r\n    }\r\n    notifyNestedListeners(updatePath, newValue, options, type = \"update\", queue, originalPath = null) {\r\n        return this.getQueueNotifyListeners(this.getNestedListeners(updatePath, newValue, options, type, originalPath), queue);\r\n    }\r\n    getNotifyOnlyListeners(updatePath, newValue, options, type = \"update\", originalPath = null) {\r\n        const listeners = {};\r\n        if (typeof options.only !== \"object\" ||\r\n            !Array.isArray(options.only) ||\r\n            typeof options.only[0] === \"undefined\" ||\r\n            !this.canBeNested(newValue)) {\r\n            return listeners;\r\n        }\r\n        for (const notifyPath of options.only) {\r\n            const wildcardScanNewValue = new WildcardObject(newValue, this.options.delimiter, this.options.wildcard).get(notifyPath);\r\n            listeners[notifyPath] = { bulk: [], single: [] };\r\n            for (const wildcardPath in wildcardScanNewValue) {\r\n                const fullPath = updatePath + this.options.delimiter + wildcardPath;\r\n                for (const [listenerPath, listenersCollection] of this.listeners) {\r\n                    const params = listenersCollection.paramsInfo\r\n                        ? this.getParams(listenersCollection.paramsInfo, fullPath)\r\n                        : undefined;\r\n                    if (this.match(listenerPath, fullPath)) {\r\n                        const value = () => wildcardScanNewValue[wildcardPath];\r\n                        const bulkValue = [{ value, path: fullPath, params }];\r\n                        for (const listener of listenersCollection.listeners.values()) {\r\n                            const eventInfo = {\r\n                                type,\r\n                                listener,\r\n                                listenersCollection,\r\n                                path: {\r\n                                    listener: listenerPath,\r\n                                    update: originalPath ? originalPath : updatePath,\r\n                                    resolved: this.cleanNotRecursivePath(fullPath),\r\n                                },\r\n                                params,\r\n                                options,\r\n                            };\r\n                            if (this.shouldIgnore(listener, updatePath))\r\n                                continue;\r\n                            if (listener.options.bulk) {\r\n                                if (!listeners[notifyPath].bulk.some((bulkListener) => bulkListener.listener === listener)) {\r\n                                    listeners[notifyPath].bulk.push({\r\n                                        listener,\r\n                                        listenersCollection,\r\n                                        eventInfo,\r\n                                        value: bulkValue,\r\n                                    });\r\n                                }\r\n                            }\r\n                            else {\r\n                                listeners[notifyPath].single.push({\r\n                                    listener,\r\n                                    listenersCollection,\r\n                                    eventInfo,\r\n                                    value,\r\n                                });\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return listeners;\r\n    }\r\n    runQueue(queue) {\r\n        const firedGroups = [];\r\n        for (const q of queue) {\r\n            if (q.options.group) {\r\n                if (!firedGroups.includes(q.groupId)) {\r\n                    q.fn();\r\n                    firedGroups.push(q.groupId);\r\n                }\r\n            }\r\n            else {\r\n                q.fn();\r\n            }\r\n        }\r\n    }\r\n    sortAndRunQueue(queue, path) {\r\n        queue.sort(function (a, b) {\r\n            return a.id - b.id;\r\n        });\r\n        if (this.options.debug) {\r\n            console.log(`[deep-state-observer] queue for ${path}`, queue);\r\n        }\r\n        this.runQueue(queue);\r\n    }\r\n    notifyOnly(updatePath, newValue, options, type = \"update\", originalPath = \"\") {\r\n        const queue = this.getQueueNotifyListeners(this.getNotifyOnlyListeners(updatePath, newValue, options, type, originalPath));\r\n        this.sortAndRunQueue(queue, updatePath);\r\n    }\r\n    canBeNested(newValue) {\r\n        return typeof newValue === \"object\" && newValue !== null;\r\n    }\r\n    getUpdateValues(oldValue, fn) {\r\n        let newValue = fn;\r\n        if (typeof fn === \"function\") {\r\n            newValue = fn(oldValue);\r\n        }\r\n        return { newValue, oldValue };\r\n    }\r\n    wildcardNotify(groupedListenersPack, waitingPaths) {\r\n        let queue = [];\r\n        for (const groupedListeners of groupedListenersPack) {\r\n            this.getQueueNotifyListeners(groupedListeners, queue);\r\n        }\r\n        for (const path of waitingPaths) {\r\n            this.executeWaitingListeners(path);\r\n        }\r\n        this.jobsRunning--;\r\n        return queue;\r\n    }\r\n    wildcardUpdate(updatePath, fn, options = defaultUpdateOptions, multi = false) {\r\n        ++this.jobsRunning;\r\n        options = Object.assign(Object.assign({}, defaultUpdateOptions), options);\r\n        const scanned = this.scan.get(updatePath);\r\n        const updated = {};\r\n        for (const path in scanned) {\r\n            const split = this.split(path);\r\n            const { oldValue, newValue } = this.getUpdateValues(scanned[path], fn);\r\n            if (!this.same(newValue, oldValue) || options.force) {\r\n                this.pathSet(split, newValue, this.data);\r\n                updated[path] = newValue;\r\n            }\r\n        }\r\n        const groupedListenersPack = [];\r\n        const waitingPaths = [];\r\n        for (const path in updated) {\r\n            const newValue = updated[path];\r\n            if (options.only.length) {\r\n                groupedListenersPack.push(this.getNotifyOnlyListeners(path, newValue, options, \"update\", updatePath));\r\n            }\r\n            else {\r\n                groupedListenersPack.push(this.getSubscribedListeners(path, newValue, options, \"update\", updatePath));\r\n                if (this.canBeNested(newValue)) {\r\n                    groupedListenersPack.push(this.getNestedListeners(path, newValue, options, \"update\", updatePath));\r\n                }\r\n            }\r\n            options.debug && this.options.log(\"Wildcard update\", { path, newValue });\r\n            waitingPaths.push(path);\r\n        }\r\n        if (multi) {\r\n            const self = this;\r\n            return function () {\r\n                const queue = self.wildcardNotify(groupedListenersPack, waitingPaths);\r\n                self.sortAndRunQueue(queue, updatePath);\r\n            };\r\n        }\r\n        const queue = this.wildcardNotify(groupedListenersPack, waitingPaths);\r\n        this.sortAndRunQueue(queue, updatePath);\r\n    }\r\n    runUpdateQueue() {\r\n        if (this.destroyed)\r\n            return;\r\n        while (this.updateQueue.length && this.updateQueue.length < this.options.maxSimultaneousJobs) {\r\n            const params = this.updateQueue.shift();\r\n            params.options.queue = false; // prevent infinite loop\r\n            this.update(params.updatePath, params.fnOrValue, params.options, params.multi);\r\n        }\r\n    }\r\n    updateNotify(updatePath, newValue, options) {\r\n        const queue = this.notifySubscribedListeners(updatePath, newValue, options);\r\n        if (this.canBeNested(newValue)) {\r\n            this.notifyNestedListeners(updatePath, newValue, options, \"update\", queue);\r\n        }\r\n        this.sortAndRunQueue(queue, updatePath);\r\n        this.executeWaitingListeners(updatePath);\r\n    }\r\n    updateNotifyAll(updateStack) {\r\n        let queue = [];\r\n        for (const current of updateStack) {\r\n            const value = current.newValue;\r\n            if (this.tracing.length) {\r\n                const traceId = this.tracing[this.tracing.length - 1];\r\n                const trace = this.traceMap.get(traceId);\r\n                trace.changed.push({\r\n                    traceId,\r\n                    updatePath: current.updatePath,\r\n                    fnOrValue: value,\r\n                    options: current.options,\r\n                });\r\n                this.traceMap.set(traceId, trace);\r\n            }\r\n            queue = queue.concat(this.notifySubscribedListeners(current.updatePath, value, current.options));\r\n            if (this.canBeNested(current.newValue)) {\r\n                this.notifyNestedListeners(current.updatePath, value, current.options, \"update\", queue);\r\n            }\r\n        }\r\n        this.runQueue(queue);\r\n    }\r\n    updateNotifyOnly(updatePath, newValue, options) {\r\n        this.notifyOnly(updatePath, newValue, options);\r\n        this.executeWaitingListeners(updatePath);\r\n    }\r\n    update(updatePath, fnOrValue, options = Object.assign({}, defaultUpdateOptions), multi = false) {\r\n        if (this.destroyed)\r\n            return;\r\n        if (this.collection) {\r\n            return this.collection.update(updatePath, fnOrValue, options);\r\n        }\r\n        if (this.tracing.length) {\r\n            const traceId = this.tracing[this.tracing.length - 1];\r\n            const trace = this.traceMap.get(traceId);\r\n            trace.changed.push({ traceId, updatePath, fnOrValue, options });\r\n            this.traceMap.set(traceId, trace);\r\n        }\r\n        const jobsRunning = this.jobsRunning;\r\n        if ((this.options.queue || options.queue) && jobsRunning) {\r\n            if (jobsRunning > this.options.maxSimultaneousJobs) {\r\n                throw new Error(\"Maximal simultaneous jobs limit reached.\");\r\n            }\r\n            this.updateQueue.push({ updatePath, fnOrValue, options, multi });\r\n            const result = Promise.resolve().then(() => {\r\n                this.runUpdateQueue();\r\n            });\r\n            if (multi) {\r\n                return function () {\r\n                    return result;\r\n                };\r\n            }\r\n            return result;\r\n        }\r\n        if (this.isWildcard(updatePath)) {\r\n            return this.wildcardUpdate(updatePath, fnOrValue, options, multi);\r\n        }\r\n        ++this.jobsRunning;\r\n        const split = this.split(updatePath);\r\n        const currentValue = this.pathGet(split, this.data);\r\n        let { oldValue, newValue } = this.getUpdateValues(currentValue, fnOrValue);\r\n        if (options.debug) {\r\n            this.options.log(`Updating ${updatePath} ${options.source ? `from ${options.source}` : \"\"}`, {\r\n                oldValue,\r\n                newValue,\r\n            });\r\n        }\r\n        if (this.same(newValue, oldValue) && !options.force) {\r\n            --this.jobsRunning;\r\n            if (multi)\r\n                return function () {\r\n                    return newValue;\r\n                };\r\n            return newValue;\r\n        }\r\n        this.pathSet(split, newValue, this.data);\r\n        options = Object.assign(Object.assign({}, defaultUpdateOptions), options);\r\n        if (options.only === null) {\r\n            --this.jobsRunning;\r\n            if (multi)\r\n                return function () { };\r\n            return newValue;\r\n        }\r\n        if (options.only.length) {\r\n            --this.jobsRunning;\r\n            if (multi) {\r\n                const self = this;\r\n                return function () {\r\n                    const result = self.updateNotifyOnly(updatePath, newValue, options);\r\n                    return result;\r\n                };\r\n            }\r\n            this.updateNotifyOnly(updatePath, newValue, options);\r\n            return newValue;\r\n        }\r\n        if (multi) {\r\n            --this.jobsRunning;\r\n            const self = this;\r\n            return function multiUpdate() {\r\n                const result = self.updateNotify(updatePath, newValue, options);\r\n                return result;\r\n            };\r\n        }\r\n        this.updateNotify(updatePath, newValue, options);\r\n        --this.jobsRunning;\r\n        return newValue;\r\n    }\r\n    multi(grouped = false) {\r\n        if (this.destroyed)\r\n            return {\r\n                update() {\r\n                    return this;\r\n                },\r\n                done() { },\r\n                getStack() {\r\n                    return [];\r\n                },\r\n            };\r\n        if (this.collection)\r\n            return this.collection;\r\n        const self = this;\r\n        const updateStack = [];\r\n        const notifiers = [];\r\n        const multiObject = {\r\n            update(updatePath, fnOrValue, options = defaultUpdateOptions) {\r\n                if (grouped) {\r\n                    const split = self.split(updatePath);\r\n                    let value = fnOrValue;\r\n                    const currentValue = self.pathGet(split, self.data);\r\n                    if (typeof value === \"function\") {\r\n                        value = value(currentValue);\r\n                    }\r\n                    self.pathSet(split, value, self.data);\r\n                    updateStack.push({ updatePath, newValue: value, options });\r\n                }\r\n                else {\r\n                    notifiers.push(self.update(updatePath, fnOrValue, options, true));\r\n                }\r\n                return this;\r\n            },\r\n            done() {\r\n                if (self.collections !== 0) {\r\n                    return;\r\n                }\r\n                if (grouped) {\r\n                    self.updateNotifyAll(updateStack);\r\n                }\r\n                else {\r\n                    for (const current of notifiers) {\r\n                        current();\r\n                    }\r\n                }\r\n                updateStack.length = 0;\r\n            },\r\n            getStack() {\r\n                return updateStack;\r\n            },\r\n        };\r\n        return multiObject;\r\n    }\r\n    collect() {\r\n        this.collections++;\r\n        if (!this.collection) {\r\n            this.collection = this.multi(true);\r\n        }\r\n        return this.collection;\r\n    }\r\n    executeCollected() {\r\n        this.collections--;\r\n        if (this.collections === 0 && this.collection) {\r\n            const collection = this.collection;\r\n            this.collection = null;\r\n            collection.done();\r\n        }\r\n    }\r\n    getCollectedCount() {\r\n        return this.collections;\r\n    }\r\n    getCollectedStack() {\r\n        if (!this.collection)\r\n            return [];\r\n        return this.collection.getStack();\r\n    }\r\n    get(userPath = undefined) {\r\n        if (this.destroyed)\r\n            return;\r\n        if (userPath === undefined || userPath === \"\") {\r\n            return this.data;\r\n        }\r\n        if (this.isWildcard(userPath)) {\r\n            return this.scan.get(userPath);\r\n        }\r\n        return this.pathGet(this.split(userPath), this.data);\r\n    }\r\n    last(callback) {\r\n        let last = this.lastExecs.get(callback);\r\n        if (!last) {\r\n            last = { calls: 0 };\r\n            this.lastExecs.set(callback, last);\r\n        }\r\n        const current = ++last.calls;\r\n        this.resolved.then(() => {\r\n            if (current === last.calls) {\r\n                this.lastExecs.set(callback, { calls: 0 });\r\n                callback();\r\n            }\r\n        });\r\n    }\r\n    isMuted(pathOrListenerFunction) {\r\n        if (!this.options.useMute)\r\n            return false;\r\n        if (typeof pathOrListenerFunction === \"function\") {\r\n            return this.isMutedListener(pathOrListenerFunction);\r\n        }\r\n        for (const mutedPath of this.muted) {\r\n            const recursive = !this.isNotRecursive(mutedPath);\r\n            const trimmedMutedPath = this.trimPath(mutedPath);\r\n            if (this.match(pathOrListenerFunction, trimmedMutedPath))\r\n                return true;\r\n            if (this.match(trimmedMutedPath, pathOrListenerFunction))\r\n                return true;\r\n            if (recursive) {\r\n                const cutPath = this.cutPath(trimmedMutedPath, pathOrListenerFunction);\r\n                if (this.match(cutPath, mutedPath))\r\n                    return true;\r\n                if (this.match(mutedPath, cutPath))\r\n                    return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    isMutedListener(listenerFunc) {\r\n        return this.mutedListeners.has(listenerFunc);\r\n    }\r\n    mute(pathOrListenerFunction) {\r\n        if (typeof pathOrListenerFunction === \"function\") {\r\n            return this.mutedListeners.add(pathOrListenerFunction);\r\n        }\r\n        this.muted.add(pathOrListenerFunction);\r\n    }\r\n    unmute(pathOrListenerFunction) {\r\n        if (typeof pathOrListenerFunction === \"function\") {\r\n            return this.mutedListeners.delete(pathOrListenerFunction);\r\n        }\r\n        this.muted.delete(pathOrListenerFunction);\r\n    }\r\n    debugSubscribe(listener, listenersCollection, listenerPath) {\r\n        if (listener.options.debug) {\r\n            this.options.log(\"listener subscribed\", {\r\n                listenerPath,\r\n                listener,\r\n                listenersCollection,\r\n            });\r\n        }\r\n    }\r\n    debugListener(time, groupedListener) {\r\n        if (groupedListener.eventInfo.options.debug || groupedListener.listener.options.debug) {\r\n            this.options.log(\"Listener fired\", {\r\n                time: Date.now() - time,\r\n                info: groupedListener,\r\n            });\r\n        }\r\n    }\r\n    debugTime(groupedListener) {\r\n        return groupedListener.listener.options.debug || groupedListener.eventInfo.options.debug ? Date.now() : 0;\r\n    }\r\n    startTrace(name, additionalData = null) {\r\n        this.traceId++;\r\n        const id = this.traceId + \":\" + name;\r\n        this.traceMap.set(id, {\r\n            id,\r\n            sort: this.traceId,\r\n            stack: this.tracing.map((i) => i),\r\n            additionalData,\r\n            changed: [],\r\n        });\r\n        this.tracing.push(id);\r\n        return id;\r\n    }\r\n    stopTrace(id) {\r\n        const result = this.traceMap.get(id);\r\n        this.tracing.pop();\r\n        this.traceMap.delete(id);\r\n        return result;\r\n    }\r\n    saveTrace(id) {\r\n        const result = this.traceMap.get(id);\r\n        this.tracing.pop();\r\n        this.traceMap.delete(id);\r\n        this.savedTrace.push(result);\r\n        return result;\r\n    }\r\n    getSavedTraces() {\r\n        const savedTrace = this.savedTrace.map((trace) => trace);\r\n        savedTrace.sort((a, b) => {\r\n            return a.sort - b.sort;\r\n        });\r\n        this.savedTrace = [];\r\n        return savedTrace;\r\n    }\r\n}\n\nexport { DeepState as default };\n","import { EventEmitter } from 'events';\nimport { has, isEmpty, cloneDeep } from 'lodash-es';\nexport { cloneDeep } from 'lodash-es';\nimport { createDataSourceManager, compiledNodeField } from '@tmagic/data-source';\nexport * from '@tmagic/data-source';\nimport { ActionType, NODE_DISABLE_CODE_BLOCK_KEY, NODE_DISABLE_DATA_SOURCE_KEY, HookType, HookCodeType, NODE_CONDS_KEY } from '@tmagic/schema';\nexport * from '@tmagic/schema';\nimport { DATA_SOURCE_FIELDS_CHANGE_EVENT_PREFIX, isNumber, isValueIncludeDataSource, setValueByKeyPath } from '@tmagic/utils';\nexport * from '@tmagic/utils';\nexport * from '@tmagic/dep';\n\nclass Env {\n  isIos = false;\n  isIphone = false;\n  isIpad = false;\n  isAndroid = false;\n  isAndroidPad = false;\n  isMac = false;\n  isWin = false;\n  isMqq = false;\n  isWechat = false;\n  isWeb = false;\n  isOpenHarmony = false;\n  constructor(ua = globalThis.navigator?.userAgent ?? \"\", options = {}) {\n    if (!ua) {\n      return;\n    }\n    this.isIphone = ua.indexOf(\"iPhone\") >= 0;\n    this.isIpad = /(iPad).*OS\\s([\\d_]+)/.test(ua);\n    this.isIos = this.isIphone || this.isIpad;\n    this.isAndroid = ua.indexOf(\"Android\") >= 0;\n    this.isAndroidPad = this.isAndroid && ua.indexOf(\"Mobile\") < 0;\n    this.isMac = ua.indexOf(\"Macintosh\") >= 0;\n    this.isWin = ua.indexOf(\"Windows\") >= 0;\n    this.isMqq = /QQ\\/([\\d.]+)/.test(ua);\n    this.isWechat = ua.indexOf(\"MicroMessenger\") >= 0 && ua.indexOf(\"wxwork\") < 0;\n    this.isOpenHarmony = ua.includes(\"OpenHarmony\");\n    this.isWeb = !this.isIos && !this.isAndroid && !this.isOpenHarmony && !/(WebOS|BlackBerry)/.test(ua);\n    Object.entries(options).forEach(([key, value]) => {\n      this[key] = value;\n    });\n  }\n}\n\nclass FlowState {\n  isAbort;\n  constructor() {\n    this.isAbort = false;\n  }\n  abort() {\n    this.isAbort = true;\n  }\n  reset() {\n    this.isAbort = false;\n  }\n}\n\nclass EventHelper extends EventEmitter {\n  app;\n  eventQueue = [];\n  nodeEventList = /* @__PURE__ */ new Map();\n  dataSourceEventList = /* @__PURE__ */ new Map();\n  beforeEventHandler;\n  afterEventHandler;\n  constructor({\n    app,\n    beforeEventHandler,\n    afterEventHandler\n  }) {\n    super();\n    this.beforeEventHandler = beforeEventHandler;\n    this.afterEventHandler = afterEventHandler;\n    this.app = app;\n  }\n  destroy() {\n    this.removeNodeEvents();\n    this.removeAllListeners();\n    this.nodeEventList.clear();\n    this.dataSourceEventList.clear();\n  }\n  bindNodeEvents(node) {\n    node.events?.forEach((event, index) => {\n      if (!event.name) {\n        return;\n      }\n      let eventNameKey = `${event.name}_${node.data.id}`;\n      const eventNames = event.name.split(\".\");\n      if (eventNames.length > 1) {\n        eventNameKey = `${eventNames[1]}_${eventNames[0]}`;\n      }\n      let eventName = Symbol(eventNameKey);\n      if (node.eventKeys.has(eventNameKey)) {\n        eventName = node.eventKeys.get(eventNameKey);\n      } else {\n        node.eventKeys.set(eventNameKey, eventName);\n      }\n      const eventHandler = (_fromCpt, ...args) => {\n        this.eventHandler(index, node, args);\n      };\n      this.nodeEventList.set(eventHandler, eventName);\n      this.on(eventName, eventHandler);\n    });\n  }\n  removeNodeEvents() {\n    Array.from(this.nodeEventList.keys()).forEach((handler) => {\n      const name = this.nodeEventList.get(handler);\n      name && this.off(name, handler);\n    });\n    this.nodeEventList.clear();\n  }\n  bindDataSourceEvents(dataSourceList) {\n    this.removeDataSourceEvents(dataSourceList);\n    dataSourceList.forEach((dataSource) => {\n      const dataSourceEvent = this.dataSourceEventList.get(dataSource.id) ?? /* @__PURE__ */ new Map();\n      (dataSource.schema.events || []).forEach((event) => {\n        const [prefix, ...path] = event.name?.split(\".\") || [];\n        if (!prefix) return;\n        const handler = (...args) => {\n          this.eventHandler(event, dataSource, args);\n        };\n        dataSourceEvent.set(event.name, handler);\n        if (prefix === DATA_SOURCE_FIELDS_CHANGE_EVENT_PREFIX) {\n          dataSource?.onDataChange(path.join(\".\"), handler);\n        } else {\n          dataSource.on(prefix, handler);\n        }\n      });\n      this.dataSourceEventList.set(dataSource.id, dataSourceEvent);\n    });\n  }\n  removeDataSourceEvents(dataSourceList) {\n    if (!this.dataSourceEventList.size) {\n      return;\n    }\n    dataSourceList.forEach((dataSource) => {\n      const dataSourceEvent = this.dataSourceEventList.get(dataSource.id);\n      if (!dataSourceEvent) return;\n      Array.from(dataSourceEvent.keys()).forEach((eventName) => {\n        const [prefix, ...path] = eventName.split(\".\");\n        if (prefix === DATA_SOURCE_FIELDS_CHANGE_EVENT_PREFIX) {\n          dataSource.offDataChange(path.join(\".\"), dataSourceEvent.get(eventName));\n        } else {\n          dataSource.off(prefix, dataSourceEvent.get(eventName));\n        }\n      });\n    });\n    this.dataSourceEventList.clear();\n  }\n  getEventQueue() {\n    return this.eventQueue;\n  }\n  addEventToQueue(event) {\n    this.eventQueue.push(event);\n  }\n  /**\n   * 事件联动处理函数\n   * @param eventsConfigIndex 事件配置索引，可以通过此索引从node.event中获取最新事件配置\n   * @param fromCpt 触发事件的组件\n   * @param args 事件参数\n   */\n  async eventHandler(config, fromCpt, args) {\n    const eventConfig = typeof config === \"number\" ? fromCpt.events[config] : config;\n    if (typeof this.beforeEventHandler === \"function\") {\n      this.beforeEventHandler({ eventConfig, source: fromCpt, args });\n    }\n    if (has(eventConfig, \"actions\")) {\n      const flowState = new FlowState();\n      const { actions } = eventConfig;\n      for (let i = 0; i < actions.length; i++) {\n        if (flowState?.isAbort) break;\n        if (typeof config === \"number\") {\n          const actionItem = fromCpt.events[config].actions[i];\n          await this.actionHandler(actionItem, fromCpt, args, flowState);\n        } else {\n          await this.actionHandler(actions[i], fromCpt, args, flowState);\n        }\n      }\n      flowState.reset();\n    } else {\n      try {\n        await this.compActionHandler(eventConfig, fromCpt, args);\n      } catch (e) {\n        if (this.app.errorHandler) {\n          this.app.errorHandler(e, fromCpt, { type: \"action-handler\", config: eventConfig, ...args });\n        } else {\n          throw e;\n        }\n      }\n    }\n    if (typeof this.afterEventHandler === \"function\") {\n      this.afterEventHandler({ eventConfig, source: fromCpt, args });\n    }\n  }\n  async actionHandler(actionItem, fromCpt, args, flowState) {\n    try {\n      if (actionItem.actionType === ActionType.COMP) {\n        const compActionItem = actionItem;\n        await this.compActionHandler(compActionItem, fromCpt, args);\n      } else if (actionItem.actionType === ActionType.CODE) {\n        if (fromCpt.data[NODE_DISABLE_CODE_BLOCK_KEY]) {\n          return;\n        }\n        const codeActionItem = actionItem;\n        await this.app.runCode(codeActionItem.codeId, codeActionItem.params || {}, args, flowState);\n      } else if (actionItem.actionType === ActionType.DATA_SOURCE) {\n        if (fromCpt.data[NODE_DISABLE_DATA_SOURCE_KEY]) {\n          return;\n        }\n        const dataSourceActionItem = actionItem;\n        const [dsId, methodName] = dataSourceActionItem.dataSourceMethod;\n        await this.app.runDataSourceMethod(dsId, methodName, dataSourceActionItem.params || {}, args, flowState);\n      }\n    } catch (e) {\n      if (this.app.errorHandler) {\n        this.app.errorHandler(e, fromCpt, { type: \"action-handler\", config: actionItem, flowState, ...args });\n      } else {\n        throw e;\n      }\n    }\n  }\n  /**\n   * 执行联动组件动作\n   * @param eventConfig 联动组件的配置\n   * @returns void\n   */\n  async compActionHandler(eventConfig, fromCpt, args) {\n    if (!this.app.page) throw new Error(\"当前没有页面\");\n    let { method: methodName, to } = eventConfig;\n    if (Array.isArray(methodName)) {\n      [to, methodName] = methodName;\n    }\n    const toNodes = [];\n    const toNode = this.app.getNode(to);\n    if (toNode) {\n      toNodes.push(toNode);\n    }\n    for (const [, page] of this.app.pageFragments) {\n      const node = page.getNode(to);\n      if (node) {\n        toNodes.push(node);\n      }\n    }\n    if (toNodes.length === 0) {\n      this.addEventToQueue({\n        toId: to,\n        method: methodName,\n        fromCpt,\n        args\n      });\n      return;\n    }\n    const instanceMethodPropmise = [];\n    for (const node of toNodes) {\n      if (node.instance) {\n        if (typeof node.instance[methodName] === \"function\") {\n          instanceMethodPropmise.push(node.instance[methodName](fromCpt, ...args));\n        }\n      } else {\n        node.addEventToQueue({\n          method: methodName,\n          fromCpt,\n          args\n        });\n      }\n    }\n    await Promise.all(instanceMethodPropmise);\n  }\n}\n\nclass Flexible {\n  designWidth = 375;\n  tid;\n  constructor(options) {\n    if (globalThis.document.readyState === \"complete\") {\n      this.setBodyFontSize();\n    } else {\n      globalThis.document.addEventListener(\"DOMContentLoaded\", this.setBodyFontSize, false);\n    }\n    globalThis.addEventListener(\"resize\", this.resizeHandler, false);\n    globalThis.addEventListener(\"pageshow\", this.pageshowHandler, false);\n    if (typeof options?.designWidth !== \"undefined\") {\n      this.setDesignWidth(options.designWidth);\n    }\n  }\n  destroy() {\n    globalThis.document.removeEventListener(\"DOMContentLoaded\", this.setBodyFontSize, false);\n    globalThis.removeEventListener(\"resize\", this.resizeHandler, false);\n    globalThis.removeEventListener(\"pageshow\", this.pageshowHandler, false);\n  }\n  setDesignWidth(width) {\n    this.designWidth = width;\n    this.refreshRem();\n  }\n  setBodyFontSize() {\n    globalThis.document.body.style.fontSize = \".12rem\";\n  }\n  refreshRem() {\n    const { width } = document.documentElement.getBoundingClientRect();\n    const fontSize = width / (this.designWidth / 100);\n    globalThis.document.documentElement.style.fontSize = `${fontSize}px`;\n    globalThis.document.documentElement.style.fontSize = `${this.correctRem(fontSize)}px`;\n  }\n  /**\n   * 纠正由于文字缩放导致的字体大小计算不正确问题\n   * @param {number} fontSize\n   * @returns {number}\n   */\n  correctRem(fontSize) {\n    const { document: document2 } = globalThis;\n    const d = document2.createElement(\"div\");\n    d.style.cssText = \"width:1rem;height:0;overflow:hidden;position:absolute;z-index:-1;visibility:hidden;\";\n    document2.documentElement.appendChild(d);\n    const dw = d.offsetWidth;\n    document2.documentElement.removeChild(d);\n    if (Math.abs(dw - fontSize) > 1) {\n      return fontSize ** 2 / dw;\n    }\n    return fontSize;\n  }\n  resizeHandler = () => {\n    clearTimeout(this.tid);\n    this.tid = setTimeout(() => {\n      this.refreshRem();\n      this.tid = void 0;\n    }, 300);\n  };\n  pageshowHandler = (e) => {\n    if (e.persisted) {\n      this.resizeHandler();\n    }\n  };\n}\n\nclass Store {\n  data;\n  constructor({ initialData = {} } = {}) {\n    this.data = initialData;\n  }\n  set(key, value) {\n    this.data[key] = value;\n  }\n  get(key) {\n    return this.data[key];\n  }\n}\n\nclass Node extends EventEmitter {\n  data;\n  style;\n  events = [];\n  instance = null;\n  page;\n  parent;\n  app;\n  store;\n  eventKeys = /* @__PURE__ */ new Map();\n  eventQueue = [];\n  constructor(options) {\n    super();\n    this.store = new Store({ initialData: options.app.nodeStoreInitialData?.() || {} });\n    this.page = options.page;\n    this.parent = options.parent;\n    this.app = options.app;\n    this.setData(options.config);\n    this.listenLifeSafe();\n  }\n  setData(data) {\n    this.data = data;\n    const { events, style } = data;\n    this.events = events || [];\n    this.style = style || {};\n    try {\n      if (this.instance && !Object.isFrozen(this.instance) && Object.getOwnPropertyDescriptor(this.instance, \"config\")?.writable !== false && !this.instance.__isVue) {\n        this.instance.config = data;\n      }\n    } catch (e) {\n    }\n    this.emit(\"update-data\", data);\n  }\n  addEventToQueue(event) {\n    this.eventQueue.push(event);\n  }\n  /**\n   * @deprecated use setInstance instead\n   */\n  registerMethod(methods) {\n    if (!methods) {\n      return;\n    }\n    if (!this.instance) {\n      this.instance = {};\n    }\n    for (const [key, fn] of Object.entries(methods)) {\n      if (typeof fn === \"function\") {\n        this.instance[key] = fn;\n      }\n    }\n  }\n  setInstance(instance) {\n    this.instance = instance;\n  }\n  async runHookCode(hook, params) {\n    if (typeof this.data[hook] === \"function\") {\n      await this.data[hook](this);\n      return;\n    }\n    const hookData = this.data[hook];\n    if (hookData?.hookType !== HookType.CODE) return;\n    for (const item of hookData.hookData) {\n      const { codeType = HookCodeType.CODE, codeId, params: itemParams = {} } = item;\n      let functionContent;\n      const functionParams = {\n        app: this.app,\n        node: this,\n        params: params || itemParams\n      };\n      if (codeType === HookCodeType.CODE && typeof codeId === \"string\" && this.app.codeDsl?.[codeId]) {\n        functionContent = this.app.codeDsl[codeId].content;\n      } else if (codeType === HookCodeType.DATA_SOURCE_METHOD && Array.isArray(codeId) && codeId.length > 1) {\n        const dataSource = this.app.dataSourceManager?.get(codeId[0]);\n        functionContent = dataSource?.methods.find((method) => method.name === codeId[1])?.content;\n        functionParams.dataSource = dataSource;\n      }\n      if (functionContent && typeof functionContent === \"function\") {\n        await functionContent(functionParams);\n      }\n    }\n  }\n  destroy() {\n    this.eventQueue.length = 0;\n    this.instance = null;\n    this.events = [];\n    this.style = {};\n    this.removeAllListeners();\n  }\n  listenLifeSafe() {\n    this.once(\"created\", (instance) => {\n      this.once(\"destroy\", () => {\n        this.instance = null;\n        if (this.data[NODE_DISABLE_CODE_BLOCK_KEY] !== true) {\n          this.runHookCode(\"destroy\");\n        }\n        this.listenLifeSafe();\n      });\n      if (instance) {\n        this.setInstance(instance);\n      }\n      if (this.data[NODE_DISABLE_CODE_BLOCK_KEY] !== true) {\n        this.runHookCode(\"created\");\n      }\n    });\n    this.once(\"mounted\", (instance) => {\n      const handler = async () => {\n        if (instance) {\n          this.setInstance(instance);\n        }\n        for (let eventConfig = this.eventQueue.shift(); eventConfig; eventConfig = this.eventQueue.shift()) {\n          if (typeof instance[eventConfig.method] === \"function\") {\n            await instance[eventConfig.method](eventConfig.fromCpt, ...eventConfig.args);\n          }\n        }\n        if (this.app.eventHelper) {\n          for (const eventConfig of this.app.eventHelper.getEventQueue()) {\n            for (const [, page] of this.app.pageFragments) {\n              const node = page.getNode(eventConfig.toId);\n              if (node && node === this) {\n                if (typeof instance[eventConfig.method] === \"function\") {\n                  await instance[eventConfig.method](eventConfig.fromCpt, ...eventConfig.args);\n                }\n                eventConfig.handled = true;\n              }\n            }\n          }\n          this.app.eventHelper.eventQueue = this.app.eventHelper.getEventQueue().filter((eventConfig) => !eventConfig.handled);\n        }\n        if (this.data[NODE_DISABLE_CODE_BLOCK_KEY] !== true) {\n          this.runHookCode(\"mounted\");\n        }\n      };\n      handler();\n    });\n  }\n}\n\nclass IteratorContainer extends Node {\n  nodes = [];\n  setData(data) {\n    this.resetNodes();\n    super.setData(data);\n  }\n  resetNodes() {\n    this.nodes?.forEach((nodeMap) => {\n      nodeMap.forEach((node) => {\n        node.destroy();\n      });\n    });\n    this.nodes = [];\n  }\n  initNode(config, parent, map) {\n    if (map.has(config.id)) {\n      map.get(config.id)?.destroy();\n    }\n    if (config.type && this.app.iteratorContainerType.has(config.type)) {\n      const iteratorContainer = new IteratorContainer({\n        config,\n        parent,\n        page: this.page,\n        app: this.app\n      });\n      map.set(config.id, iteratorContainer);\n      this.app.eventHelper?.bindNodeEvents(iteratorContainer);\n      return;\n    }\n    const node = new Node({\n      config,\n      parent,\n      page: this.page,\n      app: this.app\n    });\n    this.app.eventHelper?.bindNodeEvents(node);\n    map.set(config.id, node);\n    if (config.type && this.app.pageFragmentContainerType.has(config.type) && config.pageFragmentId) {\n      const pageFragment = this.app.dsl?.items?.find((page) => page.id === config.pageFragmentId);\n      if (pageFragment) {\n        config.items = [pageFragment];\n      }\n    }\n    config.items?.forEach((element) => {\n      this.initNode(element, node, map);\n    });\n  }\n  setNodes(nodes, index) {\n    const map = this.nodes[index] || /* @__PURE__ */ new Map();\n    nodes.forEach((node) => {\n      this.initNode(node, this, map);\n    });\n    this.nodes[index] = map;\n  }\n  getNode(id, index) {\n    return this.nodes[index]?.get(id);\n  }\n  destroy() {\n    super.destroy();\n    this.resetNodes();\n  }\n}\n\nclass Page extends Node {\n  nodes = /* @__PURE__ */ new Map();\n  constructor(options) {\n    super(options);\n    this.setNode(options.config.id, this);\n    options.config.items.forEach((config) => {\n      this.initNode(config, this);\n    });\n  }\n  initNode(config, parent) {\n    if (config.type && this.app.iteratorContainerType.has(config.type)) {\n      this.setNode(\n        config.id,\n        new IteratorContainer({\n          config,\n          parent,\n          page: this,\n          app: this.app\n        })\n      );\n      return;\n    }\n    const node = new (config.type && App.nodeClassMap.get(config.type) || Node)({\n      config,\n      parent,\n      page: this,\n      app: this.app\n    });\n    this.setNode(config.id, node);\n    if (config.type && this.app.pageFragmentContainerType.has(config.type) && config.pageFragmentId) {\n      const pageFragment = this.app.dsl?.items?.find((page) => page.id === config.pageFragmentId);\n      if (pageFragment) {\n        this.app.pageFragments.set(\n          config.id,\n          new Page({\n            config: pageFragment,\n            app: this.app\n          })\n        );\n      }\n    }\n    config.items?.forEach((element) => {\n      this.initNode(element, node);\n    });\n  }\n  getNode(id, { iteratorContainerId, iteratorIndex, pageFragmentContainerId } = {}) {\n    if (this.nodes.has(id)) {\n      return this.nodes.get(id);\n    }\n    if (pageFragmentContainerId) {\n      return this.app.pageFragments.get(pageFragmentContainerId)?.getNode(id, { iteratorContainerId, iteratorIndex });\n    }\n    if (Array.isArray(iteratorContainerId) && iteratorContainerId.length && Array.isArray(iteratorIndex)) {\n      let iteratorContainer = this.nodes.get(iteratorContainerId[0]);\n      for (let i = 1, l = iteratorContainerId.length; i < l; i++) {\n        iteratorContainer = iteratorContainer?.getNode(\n          iteratorContainerId[i],\n          iteratorIndex[i - 1]\n        );\n      }\n      return iteratorContainer?.getNode(id, iteratorIndex[iteratorIndex.length - 1]);\n    }\n  }\n  setNode(id, node) {\n    this.nodes.set(id, node);\n  }\n  deleteNode(id) {\n    this.nodes.delete(id);\n  }\n  destroy() {\n    this.nodes.forEach((node) => {\n      if (node === this) {\n        return;\n      }\n      node.destroy();\n    });\n    this.nodes.clear();\n    super.destroy();\n  }\n}\n\nconst style2Obj = (style) => {\n  if (typeof style !== \"string\") {\n    return style;\n  }\n  const obj = {};\n  style.split(\";\").forEach((element) => {\n    if (!element) {\n      return;\n    }\n    const items = element.split(\":\");\n    let key = items.shift();\n    let value = items.join(\":\");\n    if (!key) return;\n    key = key.replace(/^\\s*/, \"\").replace(/\\s*$/, \"\");\n    value = value.replace(/^\\s*/, \"\").replace(/\\s*$/, \"\");\n    key = key.split(\"-\").map((v, i) => i > 0 ? `${v[0].toUpperCase()}${v.substr(1)}` : v).join(\"\");\n    obj[key] = value;\n  });\n  return obj;\n};\nconst fillBackgroundImage = (value) => {\n  if (value && !/^url/.test(value) && !/^linear-gradient/.test(value)) {\n    return `url(${value})`;\n  }\n  return value;\n};\nconst getTransform = (value, jsEngine) => {\n  if (!value) return [];\n  const transform = Object.entries(value).map(([transformKey, transformValue]) => {\n    if (!transformValue.trim()) return \"\";\n    if (transformKey === \"rotate\" && isNumber(transformValue)) {\n      transformValue = `${transformValue}deg`;\n    }\n    return jsEngine !== \"hippy\" ? `${transformKey}(${transformValue})` : { [transformKey]: transformValue };\n  });\n  if (jsEngine === \"hippy\") {\n    return transform;\n  }\n  const values = transform.join(\" \");\n  return !values.trim() ? \"none\" : values;\n};\nconst transformStyle = (style, jsEngine) => {\n  if (!style) {\n    return {};\n  }\n  let styleObj = {};\n  const results = {};\n  if (typeof style === \"string\") {\n    styleObj = style2Obj(style);\n  } else {\n    styleObj = { ...style };\n  }\n  const isHippy = jsEngine === \"hippy\";\n  const whiteList = [\"zIndex\", \"opacity\", \"fontWeight\"];\n  Object.entries(styleObj).forEach(([key, value]) => {\n    if (key === \"scale\" && !results.transform && isHippy) {\n      results.transform = [{ scale: value }];\n    } else if (key === \"backgroundImage\" && !isHippy) {\n      value && (results[key] = fillBackgroundImage(value));\n    } else if (key === \"transform\" && typeof value !== \"string\") {\n      results[key] = getTransform(value, jsEngine);\n    } else if (!whiteList.includes(key) && value && /^[-]?[0-9]*[.]?[0-9]*$/.test(value)) {\n      results[key] = isHippy ? value : `${value / 100}rem`;\n    } else {\n      results[key] = value;\n    }\n  });\n  return results;\n};\nconst COMMON_EVENT_PREFIX = \"magic:common:events:\";\nconst COMMON_METHOD_PREFIX = \"magic:common:actions:\";\n\nclass App extends EventEmitter {\n  static nodeClassMap = /* @__PURE__ */ new Map();\n  static registerNode(type, NodeClass) {\n    App.nodeClassMap.set(type, NodeClass);\n  }\n  env;\n  dsl;\n  codeDsl;\n  dataSourceManager;\n  page;\n  pageFragments = /* @__PURE__ */ new Map();\n  useMock = false;\n  platform = \"mobile\";\n  jsEngine = \"browser\";\n  components = /* @__PURE__ */ new Map();\n  pageFragmentContainerType = /* @__PURE__ */ new Set([\"page-fragment-container\"]);\n  iteratorContainerType = /* @__PURE__ */ new Set([\"iterator-container\"]);\n  request;\n  transformStyle;\n  eventHelper;\n  errorHandler;\n  nodeStoreInitialData;\n  flexible;\n  constructor(options) {\n    super();\n    if (options.env) {\n      this.setEnv(options.env);\n    } else {\n      this.setEnv(options.ua);\n    }\n    this.errorHandler = options.errorHandler;\n    this.codeDsl = options.config?.codeBlocks;\n    options.platform && (this.platform = options.platform);\n    options.jsEngine && (this.jsEngine = options.jsEngine);\n    options.nodeStoreInitialData && (this.nodeStoreInitialData = options.nodeStoreInitialData);\n    if (options.pageFragmentContainerType) {\n      const pageFragmentContainerType = Array.isArray(options.pageFragmentContainerType) ? options.pageFragmentContainerType : [options.pageFragmentContainerType];\n      pageFragmentContainerType.forEach((type) => {\n        this.pageFragmentContainerType.add(type);\n      });\n    }\n    if (options.iteratorContainerType) {\n      const iteratorContainerType = Array.isArray(options.iteratorContainerType) ? options.iteratorContainerType : [options.iteratorContainerType];\n      iteratorContainerType.forEach((type) => {\n        this.iteratorContainerType.add(type);\n      });\n    }\n    if (typeof options.useMock === \"boolean\") {\n      this.useMock = options.useMock;\n    }\n    if (this.jsEngine === \"browser\" && !options.disabledFlexible) {\n      this.flexible = new Flexible({ designWidth: options.designWidth });\n    }\n    if (this.platform !== \"editor\") {\n      this.eventHelper = new EventHelper({\n        app: this,\n        beforeEventHandler: options.beforeEventHandler,\n        afterEventHandler: options.afterEventHandler\n      });\n    }\n    this.transformStyle = options.transformStyle || ((style) => transformStyle(style, this.jsEngine));\n    if (options.request) {\n      this.request = options.request;\n    }\n    if (options.config) {\n      this.setConfig(options.config, options.curPage, options.dataSourceManagerInitialData);\n    }\n  }\n  setEnv(ua) {\n    if (!ua || typeof ua === \"string\") {\n      this.env = new Env(ua);\n    } else {\n      this.env = ua;\n    }\n  }\n  setDesignWidth(width) {\n    this.flexible?.setDesignWidth(width);\n  }\n  /**\n   * 设置dsl\n   * @param config dsl跟节点\n   * @param curPage 当前页面id\n   * @param initialData 数据源初始数据源\n   */\n  setConfig(config, curPage, initialData) {\n    this.dsl = config;\n    if (!curPage && config.items.length) {\n      curPage = config.items[0].id;\n    }\n    if (this.dataSourceManager) {\n      this.dataSourceManager.destroy();\n    }\n    this.dataSourceManager = createDataSourceManager(this, this.useMock, initialData);\n    this.codeDsl = config.codeBlocks;\n    const pageId = curPage || this.page?.data?.id;\n    super.emit(\"dsl-change\", { dsl: config, curPage: pageId });\n    this.pageFragments.forEach((page) => {\n      page.destroy();\n    });\n    this.pageFragments.clear();\n    this.setPage(pageId);\n    if (this.dataSourceManager) {\n      const dataSourceList = Array.from(this.dataSourceManager.dataSourceMap.values());\n      this.eventHelper?.bindDataSourceEvents(dataSourceList);\n    }\n  }\n  setPage(id) {\n    const pageConfig = this.dsl?.items.find((page) => `${page.id}` === `${id}`);\n    if (!pageConfig) {\n      this.deletePage();\n      super.emit(\"page-change\");\n      return;\n    }\n    if (this.page) {\n      if (pageConfig === this.page.data) return;\n      this.page.destroy();\n    }\n    this.page = new Page({\n      config: pageConfig,\n      app: this\n    });\n    if (this.eventHelper) {\n      this.eventHelper.removeNodeEvents();\n      for (const [, node] of this.page.nodes) {\n        this.eventHelper.bindNodeEvents(node);\n      }\n      for (const [, page] of this.pageFragments) {\n        for (const [, node] of page.nodes) {\n          this.eventHelper.bindNodeEvents(node);\n        }\n      }\n    }\n    super.emit(\"page-change\", this.page);\n  }\n  deletePage() {\n    this.page?.destroy();\n    this.eventHelper?.removeNodeEvents();\n    this.page = void 0;\n  }\n  /**\n   * 兼容id参数\n   * @param id 节点id\n   * @returns Page | void\n   */\n  getPage(id) {\n    if (!id) return this.page;\n    if (this.page && `${this.page.data.id}` === `${id}`) {\n      return this.page;\n    }\n  }\n  getNode(id, options) {\n    return this.page?.getNode(id, options);\n  }\n  registerComponent(type, Component) {\n    this.components.set(type, Component);\n  }\n  unregisterComponent(type) {\n    this.components.delete(type);\n  }\n  resolveComponent(type) {\n    return this.components.get(type);\n  }\n  emit(name, ...args) {\n    const [node, ...otherArgs] = args;\n    if (this.eventHelper && node instanceof Node && node.data?.id && node.eventKeys.has(`${String(name)}_${node.data.id}`)) {\n      return this.eventHelper?.emit(node.eventKeys.get(`${String(name)}_${node.data.id}`), node, ...otherArgs);\n    }\n    return super.emit(name, ...args);\n  }\n  /**\n   * 执行代码块动作\n   * @param eventConfig 代码动作的配置\n   * @returns void\n   */\n  async runCode(codeId, params, args, flowState) {\n    if (!codeId || isEmpty(this.codeDsl)) return;\n    const content = this.codeDsl?.[codeId]?.content;\n    if (typeof content === \"function\") {\n      try {\n        await content({ app: this, params, eventParams: args, flowState });\n      } catch (e) {\n        if (this.errorHandler) {\n          this.errorHandler(e, void 0, { type: \"run-code\", codeId, params, eventParams: args, flowState });\n        } else {\n          throw e;\n        }\n      }\n    }\n  }\n  async runDataSourceMethod(dsId, methodName, params, args, flowState) {\n    if (!dsId || !methodName) return;\n    const dataSource = this.dataSourceManager?.get(dsId);\n    if (!dataSource) return;\n    try {\n      const methods = dataSource.methods || [];\n      const method = methods.find((item) => item.name === methodName);\n      if (method && typeof method.content === \"function\") {\n        await method.content({ app: this, params, dataSource, eventParams: args, flowState });\n      } else if (typeof dataSource[methodName] === \"function\") {\n        await dataSource[methodName]();\n      }\n    } catch (e) {\n      if (this.errorHandler) {\n        this.errorHandler(e, dataSource, { type: \"data-source-method\", params, eventParams: args, flowState });\n      } else {\n        throw e;\n      }\n    }\n  }\n  destroy() {\n    this.removeAllListeners();\n    this.page?.destroy();\n    this.page = void 0;\n    this.pageFragments.forEach((page) => {\n      page.destroy();\n    });\n    this.pageFragments.clear();\n    this.flexible?.destroy();\n    this.flexible = void 0;\n    this.eventHelper?.destroy();\n    this.dsl = void 0;\n    this.dataSourceManager?.destroy();\n    this.dataSourceManager = void 0;\n    this.codeDsl = void 0;\n    this.components.clear();\n    this.nodeStoreInitialData = void 0;\n  }\n}\n\nclass DevToolApi {\n  app;\n  constructor({ app }) {\n    this.app = app;\n  }\n  openPop(popId) {\n    if (typeof this.app.openPop === \"function\") {\n      return this.app.openPop(popId);\n    }\n  }\n  setDataSourceData(dsId, data, path2) {\n    const ds = this.app.dataSourceManager?.get(dsId);\n    if (!ds) {\n      return;\n    }\n    ds.setData(data, path2);\n  }\n  delDataSourceData() {\n    return;\n  }\n  requestDataSource(dsId) {\n    const ds = this.app.dataSourceManager?.get(dsId);\n    if (!ds) {\n      return;\n    }\n    if (typeof ds.refresh === \"function\") {\n      return ds.refresh();\n    }\n    if (typeof ds.request === \"function\") {\n      return ds.request();\n    }\n    ds.isInit = false;\n    this.app.dataSourceManager?.init(ds);\n  }\n  getDisplayCondRealValue(_nodeId, condItem) {\n    return this.app.dataSourceManager?.compliedConds({ [NODE_CONDS_KEY]: [{ cond: [condItem] }] });\n  }\n  async callHook(nodeId, hookName, hookData) {\n    const node = this.app.getNode(nodeId);\n    if (!node) {\n      return;\n    }\n    for (const item of hookData) {\n      await node.runHookCode(hookName, item.params);\n    }\n  }\n  trigger(nodeId, events) {\n    const node = this.app.getNode(nodeId);\n    if (!node) {\n      return;\n    }\n    this.app.emit(events.name, node);\n  }\n  updateDsl(_nodeId, _data, _path) {\n    return;\n  }\n  isValueIncludeDataSource(value2) {\n    return isValueIncludeDataSource(value2);\n  }\n  compileDataSourceValue(value2) {\n    return compiledNodeField(value2, this.app.dataSourceManager?.data || {});\n  }\n  updateCode(codeId, value, path) {\n    if (!this.app.dsl) {\n      return;\n    }\n    const { codeBlocks } = this.app.dsl;\n    if (!codeBlocks) {\n      return;\n    }\n    const code = codeBlocks[codeId];\n    if (!code) {\n      return;\n    }\n    const newCode = cloneDeep(code);\n    let fuc = value;\n    if (path === \"content\" && typeof value === \"string\" && (value.includes(\"function\") || value.includes(\"=>\"))) {\n      eval(`fuc = ${value})`);\n    }\n    setValueByKeyPath(path, fuc, newCode);\n    codeBlocks[codeId] = newCode;\n  }\n}\n\nexport { COMMON_EVENT_PREFIX, COMMON_METHOD_PREFIX, DevToolApi as DevtoolApi, Env, EventHelper, FlowState, IteratorContainer, Node, Page, App as default, fillBackgroundImage, getTransform, style2Obj, transformStyle };\n","import { COMMON_EVENT_PREFIX } from '@tmagic/core';\n\nexport default {\n  methods: [],\n  events: [{ label: '点击', value: `${COMMON_EVENT_PREFIX}click` }],\n};\n","import { COMMON_EVENT_PREFIX } from '@tmagic/core';\n\nexport default {\n  methods: [],\n  events: [{ label: '点击', value: `${COMMON_EVENT_PREFIX}click` }],\n};\n","export default {\n  methods: [],\n  events: [],\n};\n","import { COMMON_EVENT_PREFIX } from '@tmagic/core';\n\nexport default {\n  methods: [],\n  events: [{ label: '点击', value: `${COMMON_EVENT_PREFIX}click` }],\n};\n","export default {\n  methods: [\n    {\n      label: '打开蒙层',\n      value: 'openOverlay',\n    },\n    {\n      label: '关闭蒙层',\n      value: 'closeOverlay',\n    },\n  ],\n  events: [\n    {\n      label: '打开蒙层',\n      value: 'overlay:open',\n    },\n    {\n      label: '关闭蒙层',\n      value: 'overlay:close',\n    },\n  ],\n};\n","export default {\n  methods: [\n    {\n      label: '刷新页面',\n      value: 'refresh',\n    },\n  ],\n};\n","export default {\n  methods: [],\n  events: [],\n};\n","export default {\n  methods: [],\n  events: [],\n};\n","import { COMMON_EVENT_PREFIX } from '@tmagic/core';\n\nexport default {\n  methods: [],\n  events: [{ label: '点击', value: `${COMMON_EVENT_PREFIX}click` }],\n};\n","import { COMMON_EVENT_PREFIX } from '@tmagic/core';\n\nexport default {\n  methods: [],\n  events: [{ label: '点击', value: `${COMMON_EVENT_PREFIX}click` }],\n};\n","import button from '@tmagic/vue-button/src/event';\nimport container from '@tmagic/vue-container/src/event';\nimport img from '@tmagic/vue-img/src/event';\nimport iteratorContainer from '@tmagic/vue-iterator-container/src/event';\nimport overlay from '@tmagic/vue-overlay/src/event';\nimport page from '@tmagic/vue-page/src/event';\nimport pageFragment from '@tmagic/vue-page-fragment/src/event';\nimport pageFragmentContainer from '@tmagic/vue-page-fragment-container/src/event';\nimport qrcode from '@tmagic/vue-qrcode/src/event';\nimport text from '@tmagic/vue-text/src/event';\n\nconst events: Record<string, any> = {\n  'button': button,\n  'container': container,\n  'img': img,\n  'iterator-container': iteratorContainer,\n  'overlay': overlay,\n  'page': page,\n  'page-fragment': pageFragment,\n  'page-fragment-container': pageFragmentContainer,\n  'qrcode': qrcode,\n  'text': text,\n};\n\nexport default events;"],"names":["eventsModule"],"mappings":";;;;;;;;;;;;;;GAuBA,IAAI,CAAC,GAAG,OAAO,OAAO,KAAK,QAAQ,GAAG,OAAO,GAAG;GAChD,IAAI,YAAY,GAAG,CAAC,IAAI,OAAO,CAAC,CAAC,KAAK,KAAK;EAC3C,KAAI,CAAC,CAAC;OACF,SAAS,YAAY,CAAC,MAAM,EAAE,QAAQ,EAAE,IAAI,EAAE;EAClD,KAAI,OAAO,QAAQ,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE,QAAQ,EAAE,IAAI,CAAC;EAChE;;GAEA,IAAI;GACJ,IAAI,CAAC,IAAI,OAAO,CAAC,CAAC,OAAO,KAAK,UAAU,EAAE;KACxC,cAAc,GAAG,CAAC,CAAC;EACrB,EAAC,MAAM,IAAI,MAAM,CAAC,qBAAqB,EAAE;EACzC,GAAE,cAAc,GAAG,SAAS,cAAc,CAAC,MAAM,EAAE;EACnD,KAAI,OAAO,MAAM,CAAC,mBAAmB,CAAC,MAAM;UACrC,MAAM,CAAC,MAAM,CAAC,qBAAqB,CAAC,MAAM,CAAC,CAAC;MAChD;EACH,EAAC,MAAM;EACP,GAAE,cAAc,GAAG,SAAS,cAAc,CAAC,MAAM,EAAE;EACnD,KAAI,OAAO,MAAM,CAAC,mBAAmB,CAAC,MAAM,CAAC;MAC1C;EACH;;GAEA,SAAS,kBAAkB,CAAC,OAAO,EAAE;EACrC,GAAE,IAAI,OAAO,IAAI,OAAO,CAAC,IAAI,EAAE,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC;EACpD;;GAEA,IAAI,WAAW,GAAG,MAAM,CAAC,KAAK,IAAI,SAAS,WAAW,CAAC,KAAK,EAAE;KAC5D,OAAO,KAAK,KAAK,KAAK;EACxB;;EAEA,CAAA,SAAS,YAAY,GAAG;EACxB,GAAE,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC;EAC9B;EACA,CAAAA,QAAA,CAAA,OAAc,GAAG,YAAY;EAC7B,CAAAA,QAAA,CAAA,OAAA,CAAA,IAAmB,GAAG,IAAI;;EAE1B;GACA,YAAY,CAAC,YAAY,GAAG,YAAY;;EAExC,CAAA,YAAY,CAAC,SAAS,CAAC,OAAO,GAAG,SAAS;EAC1C,CAAA,YAAY,CAAC,SAAS,CAAC,YAAY,GAAG,CAAC;EACvC,CAAA,YAAY,CAAC,SAAS,CAAC,aAAa,GAAG,SAAS;;EAEhD;EACA;GACA,IAAI,mBAAmB,GAAG,EAAE;;GAE5B,SAAS,aAAa,CAAC,QAAQ,EAAE;EACjC,GAAE,IAAI,OAAO,QAAQ,KAAK,UAAU,EAAE;OAClC,MAAM,IAAI,SAAS,CAAC,kEAAkE,GAAG,OAAO,QAAQ,CAAC;EAC7G;EACA;;EAEA,CAAA,MAAM,CAAC,cAAc,CAAC,YAAY,EAAE,qBAAqB,EAAE;KACzD,UAAU,EAAE,IAAI;KAChB,GAAG,EAAE,WAAW;EAClB,KAAI,OAAO,mBAAmB;MAC3B;EACH,GAAE,GAAG,EAAE,SAAS,GAAG,EAAE;EACrB,KAAI,IAAI,OAAO,GAAG,KAAK,QAAQ,IAAI,GAAG,GAAG,CAAC,IAAI,WAAW,CAAC,GAAG,CAAC,EAAE;SAC1D,MAAM,IAAI,UAAU,CAAC,iGAAiG,GAAG,GAAG,GAAG,GAAG,CAAC;EACzI;OACI,mBAAmB,GAAG,GAAG;EAC7B;EACA,EAAC,CAAC;;GAEF,YAAY,CAAC,IAAI,GAAG,WAAW;;EAE/B,GAAE,IAAI,IAAI,CAAC,OAAO,KAAK,SAAS;EAChC,OAAM,IAAI,CAAC,OAAO,KAAK,MAAM,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC,OAAO,EAAE;OACxD,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC;EACtC,KAAI,IAAI,CAAC,YAAY,GAAG,CAAC;EACzB;;KAEE,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,aAAa,IAAI,SAAS;IACrD;;EAED;EACA;GACA,YAAY,CAAC,SAAS,CAAC,eAAe,GAAG,SAAS,eAAe,CAAC,CAAC,EAAE;EACrE,GAAE,IAAI,OAAO,CAAC,KAAK,QAAQ,IAAI,CAAC,GAAG,CAAC,IAAI,WAAW,CAAC,CAAC,CAAC,EAAE;OACpD,MAAM,IAAI,UAAU,CAAC,+EAA+E,GAAG,CAAC,GAAG,GAAG,CAAC;EACnH;EACA,GAAE,IAAI,CAAC,aAAa,GAAG,CAAC;EACxB,GAAE,OAAO,IAAI;IACZ;;GAED,SAAS,gBAAgB,CAAC,IAAI,EAAE;EAChC,GAAE,IAAI,IAAI,CAAC,aAAa,KAAK,SAAS;OAClC,OAAO,YAAY,CAAC,mBAAmB;KACzC,OAAO,IAAI,CAAC,aAAa;EAC3B;;EAEA,CAAA,YAAY,CAAC,SAAS,CAAC,eAAe,GAAG,SAAS,eAAe,GAAG;EACpE,GAAE,OAAO,gBAAgB,CAAC,IAAI,CAAC;IAC9B;;GAED,YAAY,CAAC,SAAS,CAAC,IAAI,GAAG,SAAS,IAAI,CAAC,IAAI,EAAE;KAChD,IAAI,IAAI,GAAG,EAAE;KACb,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,SAAS,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;EACpE,GAAE,IAAI,OAAO,IAAI,IAAI,KAAK,OAAO,CAAC;;EAElC,GAAE,IAAI,MAAM,GAAG,IAAI,CAAC,OAAO;KACzB,IAAI,MAAM,KAAK,SAAS;OACtB,OAAO,IAAI,OAAO,IAAI,MAAM,CAAC,KAAK,KAAK,SAAS,CAAC;UAC9C,IAAI,CAAC,OAAO;EACnB,KAAI,OAAO,KAAK;;EAEhB;KACE,IAAI,OAAO,EAAE;EACf,KAAI,IAAI,EAAE;EACV,KAAI,IAAI,IAAI,CAAC,MAAM,GAAG,CAAC;EACvB,OAAM,EAAE,GAAG,IAAI,CAAC,CAAC,CAAC;EAClB,KAAI,IAAI,EAAE,YAAY,KAAK,EAAE;EAC7B;EACA;SACM,MAAM,EAAE,CAAC;EACf;EACA;OACI,IAAI,GAAG,GAAG,IAAI,KAAK,CAAC,kBAAkB,IAAI,EAAE,GAAG,IAAI,GAAG,EAAE,CAAC,OAAO,GAAG,GAAG,GAAG,EAAE,CAAC,CAAC;EACjF,KAAI,GAAG,CAAC,OAAO,GAAG,EAAE;OAChB,MAAM,GAAG,CAAC;EACd;;EAEA,GAAE,IAAI,OAAO,GAAG,MAAM,CAAC,IAAI,CAAC;;KAE1B,IAAI,OAAO,KAAK,SAAS;EAC3B,KAAI,OAAO,KAAK;;EAEhB,GAAE,IAAI,OAAO,OAAO,KAAK,UAAU,EAAE;EACrC,KAAI,YAAY,CAAC,OAAO,EAAE,IAAI,EAAE,IAAI,CAAC;EACrC,IAAG,MAAM;EACT,KAAI,IAAI,GAAG,GAAG,OAAO,CAAC,MAAM;OACxB,IAAI,SAAS,GAAG,UAAU,CAAC,OAAO,EAAE,GAAG,CAAC;OACxC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,EAAE,EAAE,CAAC;SAC1B,YAAY,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,IAAI,CAAC;EAC5C;;EAEA,GAAE,OAAO,IAAI;IACZ;;GAED,SAAS,YAAY,CAAC,MAAM,EAAE,IAAI,EAAE,QAAQ,EAAE,OAAO,EAAE;EACvD,GAAE,IAAI,CAAC;EACP,GAAE,IAAI,MAAM;EACZ,GAAE,IAAI,QAAQ;;KAEZ,aAAa,CAAC,QAAQ,CAAC;;EAEzB,GAAE,MAAM,GAAG,MAAM,CAAC,OAAO;EACzB,GAAE,IAAI,MAAM,KAAK,SAAS,EAAE;OACxB,MAAM,GAAG,MAAM,CAAC,OAAO,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC;EACjD,KAAI,MAAM,CAAC,YAAY,GAAG,CAAC;EAC3B,IAAG,MAAM;EACT;EACA;EACA,KAAI,IAAI,MAAM,CAAC,WAAW,KAAK,SAAS,EAAE;EAC1C,OAAM,MAAM,CAAC,IAAI,CAAC,aAAa,EAAE,IAAI;qBACnB,QAAQ,CAAC,QAAQ,GAAG,QAAQ,CAAC,QAAQ,GAAG,QAAQ,CAAC;;EAEnE;EACA;EACA,OAAM,MAAM,GAAG,MAAM,CAAC,OAAO;EAC7B;EACA,KAAI,QAAQ,GAAG,MAAM,CAAC,IAAI,CAAC;EAC3B;;EAEA,GAAE,IAAI,QAAQ,KAAK,SAAS,EAAE;EAC9B;EACA,KAAI,QAAQ,GAAG,MAAM,CAAC,IAAI,CAAC,GAAG,QAAQ;OAClC,EAAE,MAAM,CAAC,YAAY;EACzB,IAAG,MAAM;EACT,KAAI,IAAI,OAAO,QAAQ,KAAK,UAAU,EAAE;EACxC;EACA,OAAM,QAAQ,GAAG,MAAM,CAAC,IAAI,CAAC;EAC7B,SAAQ,OAAO,GAAG,CAAC,QAAQ,EAAE,QAAQ,CAAC,GAAG,CAAC,QAAQ,EAAE,QAAQ,CAAC;EAC7D;QACK,MAAM,IAAI,OAAO,EAAE;EACxB,OAAM,QAAQ,CAAC,OAAO,CAAC,QAAQ,CAAC;EAChC,MAAK,MAAM;EACX,OAAM,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC;EAC7B;;EAEA;EACA,KAAI,CAAC,GAAG,gBAAgB,CAAC,MAAM,CAAC;EAChC,KAAI,IAAI,CAAC,GAAG,CAAC,IAAI,QAAQ,CAAC,MAAM,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE;EAC1D,OAAM,QAAQ,CAAC,MAAM,GAAG,IAAI;EAC5B;EACA;EACA,OAAM,IAAI,CAAC,GAAG,IAAI,KAAK,CAAC,8CAA8C;6BAC5C,QAAQ,CAAC,MAAM,GAAG,GAAG,GAAG,MAAM,CAAC,IAAI,CAAC,GAAG,aAAa;EAC9E,2BAA0B,0CAA0C;EACpE,2BAA0B,gBAAgB,CAAC;EAC3C,OAAM,CAAC,CAAC,IAAI,GAAG,6BAA6B;EAC5C,OAAM,CAAC,CAAC,OAAO,GAAG,MAAM;EACxB,OAAM,CAAC,CAAC,IAAI,GAAG,IAAI;EACnB,OAAM,CAAC,CAAC,KAAK,GAAG,QAAQ,CAAC,MAAM;SACzB,kBAAkB,CAAC,CAAC,CAAC;EAC3B;EACA;;EAEA,GAAE,OAAO,MAAM;EACf;;GAEA,YAAY,CAAC,SAAS,CAAC,WAAW,GAAG,SAAS,WAAW,CAAC,IAAI,EAAE,QAAQ,EAAE;KACxE,OAAO,YAAY,CAAC,IAAI,EAAE,IAAI,EAAE,QAAQ,EAAE,KAAK,CAAC;IACjD;;GAED,YAAY,CAAC,SAAS,CAAC,EAAE,GAAG,YAAY,CAAC,SAAS,CAAC,WAAW;;GAE9D,YAAY,CAAC,SAAS,CAAC,eAAe;EACtC,KAAI,SAAS,eAAe,CAAC,IAAI,EAAE,QAAQ,EAAE;SACvC,OAAO,YAAY,CAAC,IAAI,EAAE,IAAI,EAAE,QAAQ,EAAE,IAAI,CAAC;QAChD;;EAEL,CAAA,SAAS,WAAW,GAAG;EACvB,GAAE,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE;EACnB,KAAI,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,MAAM,CAAC;EACtD,KAAI,IAAI,CAAC,KAAK,GAAG,IAAI;EACrB,KAAI,IAAI,SAAS,CAAC,MAAM,KAAK,CAAC;SACxB,OAAO,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC;EAC5C,KAAI,OAAO,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE,SAAS,CAAC;EACtD;EACA;;EAEA,CAAA,SAAS,SAAS,CAAC,MAAM,EAAE,IAAI,EAAE,QAAQ,EAAE;KACzC,IAAI,KAAK,GAAG,EAAE,KAAK,EAAE,KAAK,EAAE,MAAM,EAAE,SAAS,EAAE,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE,IAAI,EAAE,QAAQ,EAAE,QAAQ,EAAE;KAC/F,IAAI,OAAO,GAAG,WAAW,CAAC,IAAI,CAAC,KAAK,CAAC;EACvC,GAAE,OAAO,CAAC,QAAQ,GAAG,QAAQ;EAC7B,GAAE,KAAK,CAAC,MAAM,GAAG,OAAO;EACxB,GAAE,OAAO,OAAO;EAChB;;GAEA,YAAY,CAAC,SAAS,CAAC,IAAI,GAAG,SAAS,IAAI,CAAC,IAAI,EAAE,QAAQ,EAAE;KAC1D,aAAa,CAAC,QAAQ,CAAC;EACzB,GAAE,IAAI,CAAC,EAAE,CAAC,IAAI,EAAE,SAAS,CAAC,IAAI,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC;EAChD,GAAE,OAAO,IAAI;IACZ;;GAED,YAAY,CAAC,SAAS,CAAC,mBAAmB;EAC1C,KAAI,SAAS,mBAAmB,CAAC,IAAI,EAAE,QAAQ,EAAE;SAC3C,aAAa,CAAC,QAAQ,CAAC;EAC7B,OAAM,IAAI,CAAC,eAAe,CAAC,IAAI,EAAE,SAAS,CAAC,IAAI,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC;EACjE,OAAM,OAAO,IAAI;QACZ;;EAEL;GACA,YAAY,CAAC,SAAS,CAAC,cAAc;EACrC,KAAI,SAAS,cAAc,CAAC,IAAI,EAAE,QAAQ,EAAE;SACtC,IAAI,IAAI,EAAE,MAAM,EAAE,QAAQ,EAAE,CAAC,EAAE,gBAAgB;;SAE/C,aAAa,CAAC,QAAQ,CAAC;;EAE7B,OAAM,MAAM,GAAG,IAAI,CAAC,OAAO;SACrB,IAAI,MAAM,KAAK,SAAS;EAC9B,SAAQ,OAAO,IAAI;;EAEnB,OAAM,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC;SACnB,IAAI,IAAI,KAAK,SAAS;EAC5B,SAAQ,OAAO,IAAI;;SAEb,IAAI,IAAI,KAAK,QAAQ,IAAI,IAAI,CAAC,QAAQ,KAAK,QAAQ,EAAE;EAC3D,SAAQ,IAAI,EAAE,IAAI,CAAC,YAAY,KAAK,CAAC;aAC3B,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC;gBAC/B;EACb,WAAU,OAAO,MAAM,CAAC,IAAI,CAAC;aACnB,IAAI,MAAM,CAAC,cAAc;EACnC,aAAY,IAAI,CAAC,IAAI,CAAC,gBAAgB,EAAE,IAAI,EAAE,IAAI,CAAC,QAAQ,IAAI,QAAQ,CAAC;EACxE;EACA,QAAO,MAAM,IAAI,OAAO,IAAI,KAAK,UAAU,EAAE;WACrC,QAAQ,GAAG,EAAE;;EAErB,SAAQ,KAAK,CAAC,GAAG,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE;EAC/C,WAAU,IAAI,IAAI,CAAC,CAAC,CAAC,KAAK,QAAQ,IAAI,IAAI,CAAC,CAAC,CAAC,CAAC,QAAQ,KAAK,QAAQ,EAAE;EACrE,aAAY,gBAAgB,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC,QAAQ;eACnC,QAAQ,GAAG,CAAC;eACZ;EACZ;EACA;;WAEQ,IAAI,QAAQ,GAAG,CAAC;EACxB,WAAU,OAAO,IAAI;;WAEb,IAAI,QAAQ,KAAK,CAAC;aAChB,IAAI,CAAC,KAAK,EAAE;gBACT;EACb,WAAU,SAAS,CAAC,IAAI,EAAE,QAAQ,CAAC;EACnC;;EAEA,SAAQ,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC;aACnB,MAAM,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC;;EAEhC,SAAQ,IAAI,MAAM,CAAC,cAAc,KAAK,SAAS;aACrC,IAAI,CAAC,IAAI,CAAC,gBAAgB,EAAE,IAAI,EAAE,gBAAgB,IAAI,QAAQ,CAAC;EACzE;;EAEA,OAAM,OAAO,IAAI;QACZ;;GAEL,YAAY,CAAC,SAAS,CAAC,GAAG,GAAG,YAAY,CAAC,SAAS,CAAC,cAAc;;GAElE,YAAY,CAAC,SAAS,CAAC,kBAAkB;EACzC,KAAI,SAAS,kBAAkB,CAAC,IAAI,EAAE;EACtC,OAAM,IAAI,SAAS,EAAE,MAAM,EAAE,CAAC;;EAE9B,OAAM,MAAM,GAAG,IAAI,CAAC,OAAO;SACrB,IAAI,MAAM,KAAK,SAAS;EAC9B,SAAQ,OAAO,IAAI;;EAEnB;EACA,OAAM,IAAI,MAAM,CAAC,cAAc,KAAK,SAAS,EAAE;EAC/C,SAAQ,IAAI,SAAS,CAAC,MAAM,KAAK,CAAC,EAAE;aAC1B,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC;EAC5C,WAAU,IAAI,CAAC,YAAY,GAAG,CAAC;YACtB,MAAM,IAAI,MAAM,CAAC,IAAI,CAAC,KAAK,SAAS,EAAE;EAC/C,WAAU,IAAI,EAAE,IAAI,CAAC,YAAY,KAAK,CAAC;eAC3B,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC;EAC9C;EACA,aAAY,OAAO,MAAM,CAAC,IAAI,CAAC;EAC/B;EACA,SAAQ,OAAO,IAAI;EACnB;;EAEA;EACA,OAAM,IAAI,SAAS,CAAC,MAAM,KAAK,CAAC,EAAE;WAC1B,IAAI,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC;EACtC,SAAQ,IAAI,GAAG;EACf,SAAQ,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE;EAC1C,WAAU,GAAG,GAAG,IAAI,CAAC,CAAC,CAAC;EACvB,WAAU,IAAI,GAAG,KAAK,gBAAgB,EAAE;EACxC,WAAU,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC;EACtC;EACA,SAAQ,IAAI,CAAC,kBAAkB,CAAC,gBAAgB,CAAC;WACzC,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC;EAC1C,SAAQ,IAAI,CAAC,YAAY,GAAG,CAAC;EAC7B,SAAQ,OAAO,IAAI;EACnB;;EAEA,OAAM,SAAS,GAAG,MAAM,CAAC,IAAI,CAAC;;EAE9B,OAAM,IAAI,OAAO,SAAS,KAAK,UAAU,EAAE;EAC3C,SAAQ,IAAI,CAAC,cAAc,CAAC,IAAI,EAAE,SAAS,CAAC;EAC5C,QAAO,MAAM,IAAI,SAAS,KAAK,SAAS,EAAE;EAC1C;EACA,SAAQ,KAAK,CAAC,GAAG,SAAS,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE;aAC1C,IAAI,CAAC,cAAc,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC,CAAC,CAAC;EACjD;EACA;;EAEA,OAAM,OAAO,IAAI;QACZ;;EAEL,CAAA,SAAS,UAAU,CAAC,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE;EAC1C,GAAE,IAAI,MAAM,GAAG,MAAM,CAAC,OAAO;;KAE3B,IAAI,MAAM,KAAK,SAAS;EAC1B,KAAI,OAAO,EAAE;;EAEb,GAAE,IAAI,UAAU,GAAG,MAAM,CAAC,IAAI,CAAC;KAC7B,IAAI,UAAU,KAAK,SAAS;EAC9B,KAAI,OAAO,EAAE;;EAEb,GAAE,IAAI,OAAO,UAAU,KAAK,UAAU;EACtC,KAAI,OAAO,MAAM,GAAG,CAAC,UAAU,CAAC,QAAQ,IAAI,UAAU,CAAC,GAAG,CAAC,UAAU,CAAC;;EAEtE,GAAE,OAAO,MAAM;EACf,KAAI,eAAe,CAAC,UAAU,CAAC,GAAG,UAAU,CAAC,UAAU,EAAE,UAAU,CAAC,MAAM,CAAC;EAC3E;;GAEA,YAAY,CAAC,SAAS,CAAC,SAAS,GAAG,SAAS,SAAS,CAAC,IAAI,EAAE;KAC1D,OAAO,UAAU,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC;IACpC;;GAED,YAAY,CAAC,SAAS,CAAC,YAAY,GAAG,SAAS,YAAY,CAAC,IAAI,EAAE;KAChE,OAAO,UAAU,CAAC,IAAI,EAAE,IAAI,EAAE,KAAK,CAAC;IACrC;;EAED,CAAA,YAAY,CAAC,aAAa,GAAG,SAAS,OAAO,EAAE,IAAI,EAAE;EACrD,GAAE,IAAI,OAAO,OAAO,CAAC,aAAa,KAAK,UAAU,EAAE;EACnD,KAAI,OAAO,OAAO,CAAC,aAAa,CAAC,IAAI,CAAC;EACtC,IAAG,MAAM;OACL,OAAO,aAAa,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC;EAC5C;IACC;;EAED,CAAA,YAAY,CAAC,SAAS,CAAC,aAAa,GAAG,aAAa;GACpD,SAAS,aAAa,CAAC,IAAI,EAAE;EAC7B,GAAE,IAAI,MAAM,GAAG,IAAI,CAAC,OAAO;;EAE3B,GAAE,IAAI,MAAM,KAAK,SAAS,EAAE;EAC5B,KAAI,IAAI,UAAU,GAAG,MAAM,CAAC,IAAI,CAAC;;EAEjC,KAAI,IAAI,OAAO,UAAU,KAAK,UAAU,EAAE;EAC1C,OAAM,OAAO,CAAC;EACd,MAAK,MAAM,IAAI,UAAU,KAAK,SAAS,EAAE;SACnC,OAAO,UAAU,CAAC,MAAM;EAC9B;EACA;;EAEA,GAAE,OAAO,CAAC;EACV;;EAEA,CAAA,YAAY,CAAC,SAAS,CAAC,UAAU,GAAG,SAAS,UAAU,GAAG;EAC1D,GAAE,OAAO,IAAI,CAAC,YAAY,GAAG,CAAC,GAAG,cAAc,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,EAAE;IACjE;;EAED,CAAA,SAAS,UAAU,CAAC,GAAG,EAAE,CAAC,EAAE;EAC5B,GAAE,IAAI,IAAI,GAAG,IAAI,KAAK,CAAC,CAAC,CAAC;KACvB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,CAAC;OACxB,IAAI,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;EACpB,GAAE,OAAO,IAAI;EACb;;EAEA,CAAA,SAAS,SAAS,CAAC,IAAI,EAAE,KAAK,EAAE;KAC9B,OAAO,KAAK,GAAG,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,KAAK,EAAE;OACrC,IAAI,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC;KAC/B,IAAI,CAAC,GAAG,EAAE;EACZ;;GAEA,SAAS,eAAe,CAAC,GAAG,EAAE;KAC5B,IAAI,GAAG,GAAG,IAAI,KAAK,CAAC,GAAG,CAAC,MAAM,CAAC;EACjC,GAAE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE;EACvC,KAAI,GAAG,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC,QAAQ,IAAI,GAAG,CAAC,CAAC,CAAC;EACtC;EACA,GAAE,OAAO,GAAG;EACZ;;EAEA,CAAA,SAAS,IAAI,CAAC,OAAO,EAAE,IAAI,EAAE;KAC3B,OAAO,IAAI,OAAO,CAAC,UAAU,OAAO,EAAE,MAAM,EAAE;EAChD,KAAI,SAAS,aAAa,CAAC,GAAG,EAAE;EAChC,OAAM,OAAO,CAAC,cAAc,CAAC,IAAI,EAAE,QAAQ,CAAC;SACtC,MAAM,CAAC,GAAG,CAAC;EACjB;;OAEI,SAAS,QAAQ,GAAG;EACxB,OAAM,IAAI,OAAO,OAAO,CAAC,cAAc,KAAK,UAAU,EAAE;EACxD,SAAQ,OAAO,CAAC,cAAc,CAAC,OAAO,EAAE,aAAa,CAAC;EACtD;SACM,OAAO,CAAC,EAAE,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;;EAGvC,KAAI,8BAA8B,CAAC,OAAO,EAAE,IAAI,EAAE,QAAQ,EAAE,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC;EAC3E,KAAI,IAAI,IAAI,KAAK,OAAO,EAAE;SACpB,6BAA6B,CAAC,OAAO,EAAE,aAAa,EAAE,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC;EAC3E;EACA,IAAG,CAAC;EACJ;;EAEA,CAAA,SAAS,6BAA6B,CAAC,OAAO,EAAE,OAAO,EAAE,KAAK,EAAE;EAChE,GAAE,IAAI,OAAO,OAAO,CAAC,EAAE,KAAK,UAAU,EAAE;OACpC,8BAA8B,CAAC,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,KAAK,CAAC;EACpE;EACA;;GAEA,SAAS,8BAA8B,CAAC,OAAO,EAAE,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE;EACxE,GAAE,IAAI,OAAO,OAAO,CAAC,EAAE,KAAK,UAAU,EAAE;EACxC,KAAI,IAAI,KAAK,CAAC,IAAI,EAAE;EACpB,OAAM,OAAO,CAAC,IAAI,CAAC,IAAI,EAAE,QAAQ,CAAC;EAClC,MAAK,MAAM;EACX,OAAM,OAAO,CAAC,EAAE,CAAC,IAAI,EAAE,QAAQ,CAAC;EAChC;MACG,MAAM,IAAI,OAAO,OAAO,CAAC,gBAAgB,KAAK,UAAU,EAAE;EAC7D;EACA;OACI,OAAO,CAAC,gBAAgB,CAAC,IAAI,EAAE,SAAS,YAAY,CAAC,GAAG,EAAE;EAC9D;EACA;EACA,OAAM,IAAI,KAAK,CAAC,IAAI,EAAE;EACtB,SAAQ,OAAO,CAAC,mBAAmB,CAAC,IAAI,EAAE,YAAY,CAAC;EACvD;SACM,QAAQ,CAAC,GAAG,CAAC;EACnB,MAAK,CAAC;EACN,IAAG,MAAM;OACL,MAAM,IAAI,SAAS,CAAC,qEAAqE,GAAG,OAAO,OAAO,CAAC;EAC/G;EACA;;;;;;EChfA;EACA;AACA;EACA;EACA;AACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AACA;;EAqOA,IAAI,iBAAiB,GAAG,IAAI,WAAW,CAAC,OAAO,CAAC;;EAG9C,OAAO,iBAAiB,CAAC,UAAU,KAAK;EAC1C,MAAM,UAAU,GAAG,EAAE,IAAI,EAAE;EAC3B,QAAQ,OAAO,iBAAiB,CAAC,UAAU,CAAC,GAAG,EAAE,IAAI,CAAC;EACtD;EACA,MAAM,UAAU,GAAG,EAAE,IAAI,EAAE;EAC3B,QAAQ,MAAM,GAAG,GAAG,iBAAiB,CAAC,MAAM,CAAC,GAAG,CAAC;EACjD,QAAQ,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC;EACrB,QAAQ,OAAO;EACf,UAAU,IAAI,EAAE,GAAG,CAAC,MAAM;EAC1B,UAAU,OAAO,EAAE,GAAG,CAAC,MAAM;EAC7B,SAAS;EACT;;ECwbA,MAAM,mBAAmB,GAAG,sBAAsB;;ACvrBlD,iBAAe;EAAA,EACb,SAAS,EAAC;EAAA,EACV,MAAA,EAAQ,CAAC,EAAE,KAAA,EAAO,MAAM,KAAA,EAAO,CAAA,EAAG,mBAAmB,CAAA,KAAA,CAAA,EAAS;EAChE,CAAA;;ACHA,oBAAe;EAAA,EACb,SAAS,EAAC;EAAA,EACV,MAAA,EAAQ,CAAC,EAAE,KAAA,EAAO,MAAM,KAAA,EAAO,CAAA,EAAG,mBAAmB,CAAA,KAAA,CAAA,EAAS;EAChE,CAAA;;ACLA,cAAe;EAAA,EACb,SAAS,EAAC;EAAA,EACV,QAAQ;EACV,CAAA;;ACDA,4BAAe;EAAA,EACb,SAAS,EAAC;EAAA,EACV,MAAA,EAAQ,CAAC,EAAE,KAAA,EAAO,MAAM,KAAA,EAAO,CAAA,EAAG,mBAAmB,CAAA,KAAA,CAAA,EAAS;EAChE,CAAA;;ACLA,kBAAe;EAAA,EACb,OAAA,EAAS;EAAA,IACP;EAAA,MACE,KAAA,EAAO,MAAA;EAAA,MACP,KAAA,EAAO;EAAA,KACT;EAAA,IACA;EAAA,MACE,KAAA,EAAO,MAAA;EAAA,MACP,KAAA,EAAO;EAAA;EACT,GACF;EAAA,EACA,MAAA,EAAQ;EAAA,IACN;EAAA,MACE,KAAA,EAAO,MAAA;EAAA,MACP,KAAA,EAAO;EAAA,KACT;EAAA,IACA;EAAA,MACE,KAAA,EAAO,MAAA;EAAA,MACP,KAAA,EAAO;EAAA;EACT;EAEJ,CAAA;;ACrBA,eAAe;EAAA,EACb,OAAA,EAAS;EAAA,IACP;EAAA,MACE,KAAA,EAAO,MAAA;EAAA,MACP,KAAA,EAAO;EAAA;EACT;EAEJ,CAAA;;ACPA,uBAAe;EAAA,EACb,SAAS,EAAC;EAAA,EACV,QAAQ;EACV,CAAA;;ACHA,gCAAe;EAAA,EACb,SAAS,EAAC;EAAA,EACV,QAAQ;EACV,CAAA;;ACDA,iBAAe;EAAA,EACb,SAAS,EAAC;EAAA,EACV,MAAA,EAAQ,CAAC,EAAE,KAAA,EAAO,MAAM,KAAA,EAAO,CAAA,EAAG,mBAAmB,CAAA,KAAA,CAAA,EAAS;EAChE,CAAA;;ACHA,eAAe;EAAA,EACb,SAAS,EAAC;EAAA,EACV,MAAA,EAAQ,CAAC,EAAE,KAAA,EAAO,MAAM,KAAA,EAAO,CAAA,EAAG,mBAAmB,CAAA,KAAA,CAAA,EAAS;EAChE,CAAA;;ACMA,QAAM,MAAA,GAA8B;EAAA,EAClC,QAAA,EAAU,MAAA;EAAA,EACV,WAAA,EAAa,SAAA;EAAA,EACb,KAAA,EAAO,GAAA;EAAA,EACP,oBAAA,EAAsB,iBAAA;EAAA,EACtB,SAAA,EAAW,OAAA;EAAA,EACX,MAAA,EAAQ,IAAA;EAAA,EACR,eAAA,EAAiB,YAAA;EAAA,EACjB,yBAAA,EAA2B,qBAAA;EAAA,EAC3B,QAAA,EAAU,MAAA;EAAA,EACV,MAAA,EAAQ;EACV;;;;;;;;","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12]}